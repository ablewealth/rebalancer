<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced Tax Harvesting Calculator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <!-- Load the module loader first -->
    <script>
        // Debug base URL to ensure scripts load correctly
        console.log('Current page URL:', window.location.href);
        console.log('Current page path:', window.location.pathname);
        console.log('Base directory:', window.location.pathname.substring(0, window.location.pathname.lastIndexOf('/') + 1));
    </script>
    <script src="./js/module-loader.js"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }

        .loader {
            border: 5px solid #f3f3f3;
            border-radius: 50%;
            border-top: 5px solid #3498db;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        .parent-row {
            cursor: pointer;
            background-color: #f9fafb;
            /* gray-50 */
        }

        .parent-row:hover {
            background-color: #f3f4f6;
            /* gray-100 */
        }

        .child-row {
            background-color: #ffffff;
        }

        .child-row td {
            border-top: 1px solid #f3f4f6;
        }

        .icon-rotate {
            transform: rotate(90deg);
        }

        .excluded-row {
            opacity: 0.6;
            background-color: #fef2f2;
        }

        .excluded-row:hover {
            background-color: #fecaca;
        }

        /* Compact Layout Overrides - Apply only to specific content areas, not navigation */
        .content-area .text-xs { font-size: 0.6rem; line-height: 0.75rem; }
        .content-area .text-sm { font-size: 0.65rem; line-height: 0.85rem; }
        .content-area .text-base { font-size: 0.75rem; line-height: 0.95rem; }
        .content-area .text-lg { font-size: 0.8rem; line-height: 1rem; }
        .content-area .text-xl { font-size: 0.85rem; line-height: 1.1rem; }
        .content-area .text-2xl { font-size: 0.95rem; line-height: 1.2rem; }
        .content-area .text-3xl { font-size: 1.1rem; line-height: 1.3rem; }
        .content-area .text-4xl { font-size: 1.25rem; line-height: 1.4rem; }
        
        .content-area .p-2 { padding: 0.35rem; }
        .content-area .p-3 { padding: 0.5rem; }
        .content-area .p-4 { padding: 0.6rem; }
        .content-area .p-6 { padding: 0.8rem; }
        .content-area .p-8 { padding: 1rem; }
        
        .content-area .py-1 { padding-top: 0.15rem; padding-bottom: 0.15rem; }
        .content-area .py-2 { padding-top: 0.25rem; padding-bottom: 0.25rem; }
        .content-area .py-3 { padding-top: 0.4rem; padding-bottom: 0.4rem; }
        .content-area .py-4 { padding-top: 0.5rem; padding-bottom: 0.5rem; }
        .content-area .py-8 { padding-top: 1rem; padding-bottom: 1rem; }
        
        .content-area .px-3 { padding-left: 0.4rem; padding-right: 0.4rem; }
        .content-area .px-4 { padding-left: 0.6rem; padding-right: 0.6rem; }
        .content-area .px-6 { padding-left: 0.8rem; padding-right: 0.8rem; }
        
        .content-area .mb-2 { margin-bottom: 0.3rem; }

        /* Mode Toggle Styles */
        .mode-toggle-btn {
            background-color: transparent;
            color: #6b7280;
            border: none;
            cursor: pointer;
        }

        .mode-toggle-btn.active {
            background-color: white;
            color: #1f2937;
            box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06);
        }

        .mode-toggle-btn:hover:not(.active) {
            color: #374151;
        }

        .mode-content {
            transition: all 0.3s ease-in-out;
        }
        .content-area .mb-3 { margin-bottom: 0.5rem; }
        .content-area .mb-4 { margin-bottom: 0.6rem; }
        .content-area .mb-6 { margin-bottom: 0.8rem; }
        .content-area .mb-8 { margin-bottom: 1rem; }
        
        .content-area .mt-1 { margin-top: 0.15rem; }
        .content-area .mt-2 { margin-top: 0.3rem; }
        .content-area .mt-4 { margin-top: 0.6rem; }
        .content-area .mt-8 { margin-top: 1rem; }
        
        .content-area .gap-4 { gap: 0.6rem; }
        .content-area .gap-8 { gap: 1rem; }
        
        .content-area .space-y-4 > :not([hidden]) ~ :not([hidden]) { margin-top: 0.6rem; }
        
        /* Table specific compact styling */
        .content-area table th, .content-area table td { 
            padding: 0.4rem 0.6rem !important; 
            font-size: 0.65rem !important;
            line-height: 0.85rem !important;
        }
        
        /* Button compact styling - exclude navigation */
        .content-area button:not(nav button) { 
            padding: 0.4rem 0.8rem !important; 
            font-size: 0.7rem !important;
        }
        
        /* Input compact styling */
        .content-area input, .content-area select { 
            padding: 0.35rem !important; 
            font-size: 0.65rem !important;
        }
        
        /* Reduce card padding */
        .content-area .rounded-xl { padding: 0.8rem !important; }

        /* Navigation Styles - Full sized, professional appearance */
        .nav-link {
            position: relative;
            overflow: hidden;
            min-height: 2.5rem;
            display: flex !important;
            align-items: center !important;
        }
        
        .nav-link::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
            transition: left 0.5s;
        }
        
        .nav-link:hover::before {
            left: 100%;
        }

        /* Page Header - Exclude from compact styling */
        .page-header h1 {
            font-size: 1.875rem !important; /* text-3xl */
            line-height: 2.25rem !important;
        }
        
        @media (min-width: 768px) {
            .page-header h1 {
                font-size: 2.25rem !important; /* md:text-4xl */
                line-height: 2.5rem !important;
            }
        }
        
        .page-header p {
            font-size: 1rem !important; /* text-md */
            line-height: 1.5rem !important;
        }
    </style>
</head>

<body class="bg-gray-50 text-gray-800">

    <div class="container mx-auto p-4 md:p-8 max-w-7xl">
        <!-- Navigation Bar -->
        <nav class="bg-white shadow-sm border-b border-gray-200 mb-8">
            <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
                <div class="flex justify-between items-center h-16">
                    <!-- Logo/Brand -->
                    <div class="flex items-center">
                        <div class="flex-shrink-0 flex items-center">
                            <img src="AWM-Logo.png" alt="AWM Portfolio Rebalancer" class="h-8 w-auto mr-3">
                        </div>
                    </div>
                    
                    <!-- Navigation Links -->
                    <div class="hidden md:flex items-center">
                        <div class="flex items-center space-x-6">
                            <a href="index.html" class="nav-link bg-blue-100 text-blue-700 px-4 py-2 rounded-lg text-sm font-medium flex items-center hover:bg-blue-200 transition-colors duration-200 whitespace-nowrap">
                                <svg class="w-4 h-4 mr-2 flex-shrink-0" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z"></path>
                                </svg>
                                Tax Harvesting
                            </a>
                            <a href="model-portfolios.html" class="nav-link text-gray-600 hover:text-purple-600 hover:bg-purple-50 px-4 py-2 rounded-lg text-sm font-medium transition-colors duration-200 flex items-center whitespace-nowrap">
                                <svg class="w-4 h-4 mr-2 flex-shrink-0" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 11H5m14 0a2 2 0 012 2v6a2 2 0 01-2 2H5a2 2 0 01-2-2v-6a2 2 0 012-2m14 0V9a2 2 0 00-2-2M5 11V9a2 2 0 012-2m0 0V5a2 2 0 012-2h6a2 2 0 012 2v2M7 7h10"></path>
                                </svg>
                                Model Portfolios
                            </a>
                            <a href="buy-orders.html" class="nav-link text-gray-600 hover:text-green-600 hover:bg-green-50 px-4 py-2 rounded-lg text-sm font-medium transition-colors duration-200 flex items-center whitespace-nowrap">
                                <svg class="w-4 h-4 mr-2 flex-shrink-0" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6v6m0 0v6m0-6h6m-6 0H6"></path>
                                </svg>
                                Buy Orders
                            </a>
                            <a href="price-manager.html" class="nav-link text-gray-600 hover:text-teal-600 hover:bg-teal-50 px-4 py-2 rounded-lg text-sm font-medium transition-colors duration-200 flex items-center whitespace-nowrap">
                                <svg class="w-4 h-4 mr-2 flex-shrink-0" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8c-1.657 0-3 .895-3 2s1.343 2 3 2 3 .895 3 2-1.343 2-3 2m0-8c1.11 0 2.08.402 2.599 1M12 8V7m0 1v8m0 0v1m0-1c-1.11 0-2.08-.402-2.599-1"></path>
                                </svg>
                                Price Manager
                            </a>
                            <a href="report.html" class="nav-link text-gray-600 hover:text-orange-600 hover:bg-orange-50 px-4 py-2 rounded-lg text-sm font-medium transition-colors duration-200 flex items-center whitespace-nowrap">
                                <svg class="w-4 h-4 mr-2 flex-shrink-0" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z"></path>
                                </svg>
                                Reports
                            </a>
                        </div>
                    </div>
                    
                    <!-- Mobile menu button -->
                    <div class="md:hidden">
                        <button id="mobile-menu-button" class="text-gray-600 hover:text-gray-900 focus:outline-none focus:text-gray-900 p-2 rounded-md hover:bg-gray-100 transition-colors duration-200">
                            <svg class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16"></path>
                            </svg>
                        </button>
                    </div>
                </div>
                
                <!-- Mobile menu -->
                <div id="mobile-menu" class="md:hidden hidden transition-all duration-300 ease-in-out">
                    <div class="px-2 pt-2 pb-3 space-y-1 sm:px-3 bg-gray-50 rounded-lg mt-2 shadow-lg border border-gray-200">
                        <a href="index.html" class="mobile-nav-link bg-blue-100 text-blue-700 block px-3 py-2 rounded-md text-base font-medium hover:bg-blue-200 transition-colors duration-200">
                            Tax Harvesting
                        </a>
                        <a href="model-portfolios.html" class="mobile-nav-link text-gray-600 hover:text-purple-600 hover:bg-purple-50 block px-3 py-2 rounded-md text-base font-medium transition-colors duration-200">
                            Model Portfolios
                        </a>
                        <a href="buy-orders.html" class="mobile-nav-link text-gray-600 hover:text-green-600 hover:bg-green-50 block px-3 py-2 rounded-md text-base font-medium transition-colors duration-200">
                            Buy Orders
                        </a>
                        <a href="price-manager.html" class="mobile-nav-link text-gray-600 hover:text-teal-600 hover:bg-teal-50 block px-3 py-2 rounded-md text-base font-medium transition-colors duration-200">
                            Price Manager
                        </a>
                        <a href="report.html" class="mobile-nav-link text-gray-600 hover:text-orange-600 hover:bg-orange-50 block px-3 py-2 rounded-md text-base font-medium transition-colors duration-200">
                            Reports
                        </a>
                    </div>
                </div>
            </div>
        </nav>

        <!-- Breadcrumb -->
        <div class="content-area">
        <div class="mb-6">
            <nav class="flex" aria-label="Breadcrumb">
                <ol class="inline-flex items-center space-x-1 md:space-x-3">
                    <li class="inline-flex items-center">
                        <svg class="w-4 h-4 mr-2" fill="currentColor" viewBox="0 0 20 20">
                            <path d="M10.707 2.293a1 1 0 00-1.414 0l-7 7a1 1 0 001.414 1.414L4 10.414V17a1 1 0 001 1h2a1 1 0 001-1v-2a1 1 0 011-1h2a1 1 0 011 1v2a1 1 0 001 1h2a1 1 0 001-1v-6.586l.293.293a1 1 0 001.414-1.414l-7-7z"></path>
                        </svg>
                        <span class="text-sm font-medium text-blue-700">Tax Harvesting Calculator</span>
                    </li>
                </ol>
            </nav>
        </div>

        <!-- Page Header -->
        <div class="text-center mb-8 page-header">
            <h1 class="text-3xl md:text-4xl font-bold text-gray-900">Advanced Tax Harvesting Optimization</h1>
            <p class="text-md text-gray-600 mt-2">This tool uses an optimization algorithm to find trades that best meet your tax goals.</p>
        </div>

        <div class="grid grid-cols-1 md:grid-cols-2 gap-8">
            <!-- Input Section -->
            <div class="bg-white p-6 rounded-xl shadow-md border border-gray-200">
                <h2 class="text-2xl font-semibold mb-4 border-b pb-3">1. Your Portfolio Data</h2>

                <div class="grid grid-cols-1 sm:grid-cols-2 gap-4 mb-4">
                    <div>
                        <label for="clientName" class="block text-sm font-medium text-gray-700">Client Name</label>
                        <input type="text" id="clientName" placeholder="John Doe"
                            class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500 sm:text-sm p-2">
                    </div>
                    <div>
                        <label for="custodian" class="block text-sm font-medium text-gray-700">Custodian</label>
                        <input type="text" id="custodian" placeholder="Fidelity"
                            class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500 sm:text-sm p-2">
                    </div>
                </div>

                <div class="mb-4">
                    <label for="accountNumber" class="block text-sm font-medium text-gray-700">Account Number</label>
                    <input type="text" id="accountNumber" placeholder="Enter Account Number"
                        class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500 sm:text-sm p-2">
                </div>

                <div class="mb-4">
                    <label for="costBasisFile" class="block text-sm font-medium text-gray-700 mb-2">A. Upload Cost Basis
                        CSV (Current Holdings)</label>
                    <input type="file" id="costBasisFile" accept=".csv"
                        class="block w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-lg file:border-0 file:text-sm file:font-semibold file:bg-blue-50 file:text-blue-700 hover:file:bg-blue-100 transition-colors duration-200 cursor-pointer">
                    <p id="cost-basis-file-name" class="text-xs text-gray-500 mt-1"></p>
                </div>

                <div class="mb-6">
                    <label for="ytdFile" class="block text-sm font-medium text-gray-700 mb-2">B. Upload YTD Realized
                        Gains CSV (Optional)</label>
                    <input type="file" id="ytdFile" accept=".csv"
                        class="block w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-lg file:border-0 file:text-sm file:font-semibold file:bg-blue-50 file:text-blue-700 hover:file:bg-blue-100 transition-colors duration-200 cursor-pointer">
                    <p id="ytd-file-name" class="text-xs text-gray-500 mt-1"></p>
                </div>

                <div>
                    <h3 class="text-lg font-medium text-gray-800 mb-3">Year-to-Date Realized Gains (Auto-filled or
                        Manual)</h3>
                    <div class="grid grid-cols-1 sm:grid-cols-2 gap-4">
                        <div>
                            <label for="realizedST" class="block text-sm font-medium text-gray-700">Short-Term
                                Gain/(Loss)</label>
                            <input type="number" id="realizedST" placeholder="0.00"
                                class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500 sm:text-sm p-2">
                        </div>
                        <div>
                            <label for="realizedLT" class="block text-sm font-medium text-gray-700">Long-Term
                                Gain/(Loss)</label>
                            <input type="number" id="realizedLT" placeholder="0.00"
                                class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500 sm:text-sm p-2">
                        </div>
                    </div>
                </div>

                <!-- Wash Sale Settings -->
                <div class="mt-6 p-4 bg-yellow-50 border border-yellow-200 rounded-lg">
                    <h3 class="text-lg font-medium text-gray-800 mb-3 flex items-center">
                        <svg class="h-5 w-5 mr-2 text-yellow-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-2.5L13.732 4c-.77-.833-1.964-.833-2.732 0L4.082 16.5c-.77.833.192 2.5 1.732 2.5z"></path>
                        </svg>
                        Wash Sale Compliance Settings
                    </h3>
                    <div class="space-y-3">
                        <div>
                            <label class="flex items-center">
                                <input type="checkbox" id="enableWashSaleCheck" checked
                                    class="rounded border-gray-300 text-blue-600 focus:ring-blue-500">
                                <span class="ml-2 text-sm text-gray-700">Enable automatic wash sale detection</span>
                            </label>
                        </div>
                        <div>
                            <label class="flex items-center">
                                <input type="checkbox" id="conservativeMode" checked
                                    class="rounded border-gray-300 text-blue-600 focus:ring-blue-500">
                                <span class="ml-2 text-sm text-gray-700">Use conservative similarity scoring (recommended)</span>
                            </label>
                        </div>
                        <div class="text-xs text-yellow-700 bg-yellow-100 p-2 rounded border border-yellow-200">
                            <p><strong>Important:</strong> This tool cannot detect purchases in other accounts (spouse, IRA, etc.). 
                            You must manually verify compliance across all your accounts.</p>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Target Section -->
            <div class="bg-white p-6 rounded-xl shadow-md border border-gray-200">
                <h2 class="text-2xl font-semibold mb-4 border-b pb-3">2. Choose Your Strategy</h2>
                
                <!-- Mode Toggle -->
                <div class="mb-6">
                    <div class="flex items-center justify-center space-x-1 bg-gray-100 rounded-lg p-1">
                        <button id="taxTargetModeBtn" class="mode-toggle-btn active flex-1 py-2 px-4 text-sm font-medium rounded-md transition-all duration-200">
                            <svg class="w-4 h-4 inline mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 7h6m0 10v-3m-3 3h.01M9 17h.01M9 14h.01M12 14h.01M15 11h.01M12 11h.01M9 11h.01M7 21h10a2 2 0 002-2V5a2 2 0 00-2-2H7a2 2 0 00-2 2v14a2 2 0 002 2z"></path>
                            </svg>
                            Tax Target Mode
                        </button>
                        <button id="cashRaisingModeBtn" class="mode-toggle-btn flex-1 py-2 px-4 text-sm font-medium rounded-md transition-all duration-200">
                            <svg class="w-4 h-4 inline mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8c-1.657 0-3 .895-3 2s1.343 2 3 2 3 .895 3 2-1.343 2-3 2m0-8c1.11 0 2.08.402 2.599 1M12 8V7m0 1v8m0 0v1m0-1c-1.11 0-2.08-.402-2.599-1"></path>
                            </svg>
                            Cash Raising Mode
                        </button>
                    </div>
                </div>

                <!-- Tax Target Mode -->
                <div id="taxTargetMode" class="mode-content">
                    <p class="text-sm text-gray-600 mb-4">Define your desired total capital gain or loss for the year.</p>
                    <div class="grid grid-cols-1 sm:grid-cols-2 gap-4 mb-6">
                        <div>
                            <label for="targetST" class="block text-sm font-medium text-gray-700">Target Short-Term
                                Gain/(Loss)</label>
                            <input type="number" id="targetST" placeholder="e.g., 2000"
                                class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm p-2">
                        </div>
                        <div>
                            <label for="targetLT" class="block text-sm font-medium text-gray-700">Target Long-Term
                                Gain/(Loss)</label>
                            <input type="number" id="targetLT" placeholder="e.g., 5000"
                                class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm p-2">
                        </div>
                    </div>
                </div>

                <!-- Cash Raising Mode -->
                <div id="cashRaisingMode" class="mode-content hidden">
                    <p class="text-sm text-gray-600 mb-4">Specify the cash amount needed and set acceptable tax impact thresholds. The algorithm will optimize for the best tax outcome within your constraints.</p>
                    
                    <!-- Cash Amount -->
                    <div class="mb-4">
                        <label for="cashAmount" class="block text-sm font-medium text-gray-700">Cash Amount Needed</label>
                        <div class="mt-1 relative rounded-md shadow-sm">
                            <div class="absolute inset-y-0 left-0 pl-3 flex items-center pointer-events-none">
                                <span class="text-gray-500 sm:text-sm">$</span>
                            </div>
                            <input type="number" id="cashAmount" placeholder="50000"
                                class="pl-7 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm p-2">
                        </div>
                    </div>

                    <!-- Tax Impact Thresholds -->
                    <div class="mb-4">
                        <h3 class="text-sm font-medium text-gray-700 mb-3">Tax Impact Thresholds (Optional)</h3>
                        <p class="text-xs text-gray-500 mb-3">Set maximum acceptable tax impact. Leave blank for no limits.</p>
                        
                        <div class="grid grid-cols-1 sm:grid-cols-2 gap-4">
                            <div>
                                <label for="maxSTGain" class="block text-xs font-medium text-gray-600">Max Short-Term Gain</label>
                                <div class="mt-1 relative rounded-md shadow-sm">
                                    <div class="absolute inset-y-0 left-0 pl-3 flex items-center pointer-events-none">
                                        <span class="text-gray-400 text-xs">$</span>
                                    </div>
                                    <input type="number" id="maxSTGain" placeholder="e.g., 10000"
                                        class="pl-7 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 text-xs p-2">
                                </div>
                            </div>
                            <div>
                                <label for="maxLTGain" class="block text-xs font-medium text-gray-600">Max Long-Term Gain</label>
                                <div class="mt-1 relative rounded-md shadow-sm">
                                    <div class="absolute inset-y-0 left-0 pl-3 flex items-center pointer-events-none">
                                        <span class="text-gray-400 text-xs">$</span>
                                    </div>
                                    <input type="number" id="maxLTGain" placeholder="e.g., 25000"
                                        class="pl-7 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 text-xs p-2">
                                </div>
                            </div>
                            <div>
                                <label for="minSTLoss" class="block text-xs font-medium text-gray-600">Min Short-Term Loss</label>
                                <div class="mt-1 relative rounded-md shadow-sm">
                                    <div class="absolute inset-y-0 left-0 pl-3 flex items-center pointer-events-none">
                                        <span class="text-gray-400 text-xs">-$</span>
                                    </div>
                                    <input type="number" id="minSTLoss" placeholder="e.g., 3000"
                                        class="pl-8 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 text-xs p-2">
                                </div>
                            </div>
                            <div>
                                <label for="minLTLoss" class="block text-xs font-medium text-gray-600">Min Long-Term Loss</label>
                                <div class="mt-1 relative rounded-md shadow-sm">
                                    <div class="absolute inset-y-0 left-0 pl-3 flex items-center pointer-events-none">
                                        <span class="text-gray-400 text-xs">-$</span>
                                    </div>
                                    <input type="number" id="minLTLoss" placeholder="e.g., 5000"
                                        class="pl-8 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 text-xs p-2">
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Strategy Options -->
                    <div class="mb-6">
                        <h3 class="text-sm font-medium text-gray-700 mb-3">Optimization Strategy</h3>
                        <div class="space-y-2">
                            <label class="flex items-center">
                                <input type="radio" name="cashStrategy" value="minimize_tax" checked
                                    class="h-4 w-4 text-indigo-600 focus:ring-indigo-500 border-gray-300">
                                <span class="ml-2 text-sm text-gray-700">Minimize Tax Impact (Prioritize losses, then LT gains)</span>
                            </label>
                            <label class="flex items-center">
                                <input type="radio" name="cashStrategy" value="balanced"
                                    class="h-4 w-4 text-indigo-600 focus:ring-indigo-500 border-gray-300">
                                <span class="ml-2 text-sm text-gray-700">Balanced Approach (Consider both tax impact and liquidity)</span>
                            </label>
                            <label class="flex items-center">
                                <input type="radio" name="cashStrategy" value="maximize_cash"
                                    class="h-4 w-4 text-indigo-600 focus:ring-indigo-500 border-gray-300">
                                <span class="ml-2 text-sm text-gray-700">Maximize Cash (Prioritize largest positions first)</span>
                            </label>
                        </div>
                    </div>
                </div>

                <div class="flex flex-col space-y-4">
                    <button id="calculateBtn"
                        class="w-full bg-blue-600 text-white font-bold py-3 px-4 rounded-lg hover:bg-blue-700 transition-all duration-200 shadow-md flex items-center justify-center">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-2" viewBox="0 0 20 20"
                            fill="currentColor">
                            <path fill-rule="evenodd"
                                d="M6 2a2 2 0 00-2 2v12a2 2 0 002 2h8a2 2 0 002-2V4a2 2 0 00-2-2H6zm1 2a1 1 0 00-1 1v1a1 1 0 001 1h6a1 1 0 001-1V5a1 1 0 00-1-1H7zm6 6a1 1 0 01-1 1H8a1 1 0 110-2h4a1 1 0 011 1zm-3 4a1 1 0 100-2H8a1 1 0 100 2h2z"
                                clip-rule="evenodd" />
                        </svg>
                        Generate Recommendations
                    </button>
                    <button id="washSaleCheckBtn"
                        class="w-full bg-orange-600 text-white font-bold py-3 px-4 rounded-lg hover:bg-orange-700 transition-all duration-200 shadow-md flex items-center justify-center hidden">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-2" viewBox="0 0 20 20" fill="currentColor">
                            <path fill-rule="evenodd" d="M8.257 3.099c.765-1.36 2.722-1.36 3.486 0l5.58 9.92c.75 1.334-.21 3.03-1.742 3.03H4.42c-1.532 0-2.492-1.696-1.742-3.03l5.58-9.92zM10 13a1 1 0 110-2 1 1 0 010 2zm-1-4a1 1 0 011-1h.01a1 1 0 110 2H10a1 1 0 01-1-1z" clip-rule="evenodd" />
                        </svg>
                        Check Wash Sale Risk
                    </button>
                    <button id="exportBtn"
                        class="w-full bg-green-600 text-white font-bold py-3 px-4 rounded-lg hover:bg-green-700 transition-all duration-200 shadow-md flex items-center justify-center hidden">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-2" viewBox="0 0 20 20"
                            fill="currentColor">
                            <path
                                d="M10 2a1 1 0 00-1 1v1a1 1 0 002 0V3a1 1 0 00-1-1zM4 5a1 1 0 011-1h10a1 1 0 110 2H5a1 1 0 01-1-1zM10 18a1 1 0 01-1-1v-6a1 1 0 112 0v6a1 1 0 01-1-1z" />
                            <path fill-rule="evenodd"
                                d="M3.293 7.293a1 1 0 011.414 0L10 12.586l5.293-5.293a1 1 0 111.414 1.414l-6 6a1 1 0 01-1.414 0l-6-6a1 1 0 010-1.414z"
                                clip-rule="evenodd" />
                        </svg>
                        Export to CSV
                    </button>
                    <button id="proceedToBuyBtn"
                        class="w-full bg-purple-600 text-white font-bold py-3 px-4 rounded-lg hover:bg-purple-700 transition-all duration-200 shadow-md flex items-center justify-center hidden">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-2" viewBox="0 0 20 20"
                            fill="currentColor">
                            <path fill-rule="evenodd"
                                d="M10 5a1 1 0 011 1v3h3a1 1 0 110 2h-3v3a1 1 0 11-2 0v-3H6a1 1 0 110-2h3V6a1 1 0 011-1z"
                                clip-rule="evenodd" />
                        </svg>
                        Proceed to Buy Orders
                    </button>
                    <button id="demoWashSaleBtn"
                        class="w-full bg-purple-600 text-white font-bold py-3 px-4 rounded-lg hover:bg-purple-700 transition-all duration-200 shadow-md flex items-center justify-center">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-2" viewBox="0 0 20 20" fill="currentColor">
                            <path d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z" />
                        </svg>
                        Demo Wash Sale Detection
                    </button>
                </div>
            </div>
        </div>

        <!-- Current Portfolio Section -->
        <div id="portfolio-container" class="mt-8 bg-white p-6 rounded-xl shadow-md border border-gray-200 hidden">
            <h2 class="text-2xl font-semibold mb-4 border-b pb-3">Current Portfolio Holdings</h2>
            <p class="text-sm text-gray-600 mb-4">Review your current holdings and uncheck any positions you want to
                exclude from the selling algorithm.</p>

            <div class="mb-4 flex items-center justify-between">
                <div class="flex items-center space-x-4">
                    <button id="selectAllBtn"
                        class="text-sm bg-blue-100 text-blue-700 px-3 py-1 rounded hover:bg-blue-200">Select
                        All</button>
                    <button id="deselectAllBtn"
                        class="text-sm bg-gray-100 text-gray-700 px-3 py-1 rounded hover:bg-gray-200">Deselect
                        All</button>
                </div>
                <div class="text-sm text-gray-500">
                    <span id="selected-count">0</span> of <span id="total-count">0</span> positions selected
                </div>
            </div>

            <div class="overflow-x-auto">
                <table class="min-w-full divide-y divide-gray-200">
                    <thead class="bg-gray-50">
                        <tr>
                            <th scope="col"
                                class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                                <input type="checkbox" id="selectAllCheckbox"
                                    class="rounded border-gray-300 text-blue-600 focus:ring-blue-500">
                            </th>
                            <th scope="col"
                                class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                                Symbol</th>
                            <th scope="col"
                                class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                                Acquired</th>
                            <th scope="col"
                                class="px-6 py-3 text-right text-xs font-medium text-gray-500 uppercase tracking-wider">
                                Quantity</th>
                            <th scope="col"
                                class="px-6 py-3 text-right text-xs font-medium text-gray-500 uppercase tracking-wider">
                                Price</th>
                            <th scope="col"
                                class="px-6 py-3 text-right text-xs font-medium text-gray-500 uppercase tracking-wider">
                                Market Value</th>
                            <th scope="col"
                                class="px-6 py-3 text-right text-xs font-medium text-gray-500 uppercase tracking-wider">
                                Cost Basis</th>
                            <th scope="col"
                                class="px-6 py-3 text-right text-xs font-medium text-gray-500 uppercase tracking-wider">
                                Unrealized Gain/Loss</th>
                            <th scope="col"
                                class="px-6 py-3 text-center text-xs font-medium text-gray-500 uppercase tracking-wider">
                                Term</th>
                        </tr>
                    </thead>
                    <tbody id="portfolio-table" class="bg-white divide-y divide-gray-200">
                    </tbody>
                </table>
            </div>
        </div>

        <!-- Results Section -->
        <div id="results-container" class="mt-8 bg-white p-6 rounded-xl shadow-md border border-gray-200 hidden">
            <div id="loader" class="flex justify-center items-center h-40 hidden">
                <div class="loader"></div>
                <p class="ml-4 text-gray-600">Finding optimal trades...</p>
            </div>
            <div id="recommendations" class="hidden">
                <h2 class="text-2xl font-semibold mb-4 border-b pb-3">3. Recommended Trades</h2>
            <div id="summary" class="mb-6 p-4 bg-gray-100 rounded-lg grid grid-cols-1 md:grid-cols-2 gap-4"></div>
            <div class="overflow-x-auto">
                <table class="min-w-full divide-y divide-gray-200">
                    <thead class="bg-gray-50">
                        <tr>
                            <th scope="col"
                                class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                                Action</th>
                            <th scope="col"
                                class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                                Symbol</th>
                            <th scope="col"
                                class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                                Total Qty</th>
                            <th scope="col"
                                class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                                Acquired Date</th>
                            <th scope="col"
                                class="px-6 py-3 text-right text-xs font-medium text-gray-500 uppercase tracking-wider">
                                Market Value</th>
                            <th scope="col"
                                class="px-6 py-3 text-right text-xs font-medium text-gray-500 uppercase tracking-wider">
                                Est. Gain/(Loss)</th>
                        </tr>
                    </thead>
                    <tbody id="recommendations-table" class="bg-white divide-y divide-gray-200">
                    </tbody>
                </table>
            </div>
            <p id="no-trades-msg" class="text-center text-gray-500 py-8 hidden">No trades are needed to meet your
                targets, or no suitable lots were found.</p>
            <div id="wash-sale-warning" class="mt-6 p-4 border-l-4 border-yellow-400 bg-yellow-50 hidden">
                <div class="flex">
                    <div class="flex-shrink-0">
                        <svg class="h-5 w-5 text-yellow-400" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"
                            fill="currentColor" aria-hidden="true">
                            <path fill-rule="evenodd"
                                d="M8.257 3.099c.765-1.36 2.722-1.36 3.486 0l5.58 9.92c.75 1.334-.21 3.03-1.742 3.03H4.42c-1.532 0-2.492-1.696-1.742-3.03l5.58-9.92zM10 13a1 1 0 110-2 1 1 0 010 2zm-1-4a1 1 0 011-1h.01a1 1 0 110 2H10a1 1 0 01-1-1z"
                                clip-rule="evenodd" />
                        </svg>
                    </div>
                    <div class="ml-3">
                        <p class="text-sm text-yellow-700">
                            <strong>Wash Sale Rule Warning:</strong> Selling a security for a loss and buying the
                            same or a "substantially identical" security within 30 days (before or after the sale)
                            will result in a wash sale. The IRS disallows the loss deduction for wash sales. Please
                            be mindful of your trading activity around the dates of these recommended sales.
                        </p>
                    </div>
                </div>
            </div>
            
            <!-- AI Trade Rationale Section -->
            <div id="ai-rationale-section" class="mt-6 p-4 border border-gray-200 rounded-lg bg-gradient-to-r from-blue-50 to-indigo-50 hidden">
                <div class="flex items-center justify-between mb-4">
                    <h3 class="text-lg font-semibold text-gray-900 flex items-center">
                        <svg class="w-5 h-5 mr-2 text-blue-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z"></path>
                        </svg>
                        AI Trade Rationale
                    </h3>
                    <button id="generate-ai-rationale-btn" 
                            class="bg-blue-600 text-white px-4 py-2 rounded-lg hover:bg-blue-700 transition-colors duration-200 flex items-center text-sm font-medium">
                        <svg class="w-4 h-4 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 10V3L4 14h7v7l9-11h-7z"></path>
                        </svg>
                        Generate Analysis
                    </button>
                </div>
                
                <div id="ai-rationale-loading" class="hidden">
                    <div class="flex items-center justify-center py-8">
                        <div class="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-600"></div>
                        <span class="ml-3 text-gray-600">Generating AI analysis of your tax harvesting strategy...</span>
                    </div>
                </div>
                
                <div id="ai-rationale-content" class="hidden">
                    <div class="bg-white rounded-lg p-4 shadow-sm border border-gray-100">
                        <div class="prose prose-sm max-w-none">
                            <div id="ai-rationale-text" class="text-gray-700 leading-relaxed whitespace-pre-wrap"></div>
                        </div>
                        <div class="mt-4 pt-3 border-t border-gray-200 flex items-center justify-between">
                            <span class="text-xs text-gray-500">Generated by AI • Review recommendations with your advisor</span>
                            <button id="copy-rationale-btn" 
                                    class="text-blue-600 hover:text-blue-800 text-sm font-medium flex items-center">
                                <svg class="w-4 h-4 mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z"></path>
                                </svg>
                                Copy Analysis
                            </button>
                        </div>
                    </div>
                </div>
            </div>
            </div>
        </div>
    </div>

    <script>
        console.log('Script loaded and executing...');
        // --- DOM Elements ---
        const costBasisFileInput = document.getElementById('costBasisFile');
        const ytdFileInput = document.getElementById('ytdFile');
        const costBasisFileNameDisplay = document.getElementById('cost-basis-file-name');
        const ytdFileNameDisplay = document.getElementById('ytd-file-name');
        const calculateBtn = document.getElementById('calculateBtn');
        const washSaleCheckBtn = document.getElementById('washSaleCheckBtn');
        const exportBtn = document.getElementById('exportBtn');
        const resultsContainer = document.getElementById('results-container');
        const loader = document.getElementById('loader');
        const recommendationsDiv = document.getElementById('recommendations');
        const recommendationsTable = document.getElementById('recommendations-table');
        const summaryDiv = document.getElementById('summary');
        const noTradesMsg = document.getElementById('no-trades-msg');
        const washSaleWarning = document.getElementById('wash-sale-warning');
        const portfolioContainer = document.getElementById('portfolio-container');
        const portfolioTable = document.getElementById('portfolio-table');
        const selectAllBtn = document.getElementById('selectAllBtn');
        const deselectAllBtn = document.getElementById('deselectAllBtn');
        const selectAllCheckbox = document.getElementById('selectAllCheckbox');
        const selectedCountSpan = document.getElementById('selected-count');
        const totalCountSpan = document.getElementById('total-count');
        
        // AI Trade Rationale Elements
        const aiRationaleSection = document.getElementById('ai-rationale-section');
        const generateAiRationaleBtn = document.getElementById('generate-ai-rationale-btn');
        const aiRationaleLoading = document.getElementById('ai-rationale-loading');
        const aiRationaleContent = document.getElementById('ai-rationale-content');
        const aiRationaleText = document.getElementById('ai-rationale-text');
        const copyRationaleBtn = document.getElementById('copy-rationale-btn');
        const proceedToBuyBtn = document.getElementById('proceedToBuyBtn');
        const demoWashSaleBtn = document.getElementById('demoWashSaleBtn');

        let portfolioData = [];
        let lastRecommendations = [];
        let lastSummaryData = {};
        
        // Wash Sale Avoidance System - ETF Database and Similarity Scoring
        const etfDatabase = {
            // S&P 500 Family - High Risk
            'IVV': { name: 'iShares Core S&P 500 ETF', index: 'S&P 500', assetClass: 'US Large Cap', style: 'Blend', issuer: 'iShares' },
            'VOO': { name: 'Vanguard S&P 500 ETF', index: 'S&P 500', assetClass: 'US Large Cap', style: 'Blend', issuer: 'Vanguard' },
            'SPY': { name: 'SPDR S&P 500 ETF Trust', index: 'S&P 500', assetClass: 'US Large Cap', style: 'Blend', issuer: 'State Street' },
            'SPLG': { name: 'SPDR Portfolio S&P 500 ETF', index: 'S&P 500', assetClass: 'US Large Cap', style: 'Blend', issuer: 'State Street' },
            
            // S&P 500 Growth/Value - Moderate Risk
            'SPYG': { name: 'SPDR Portfolio S&P 500 Growth ETF', index: 'S&P 500 Growth', assetClass: 'US Large Cap', style: 'Growth', issuer: 'State Street' },
            'VOOG': { name: 'Vanguard S&P 500 Growth ETF', index: 'S&P 500 Growth', assetClass: 'US Large Cap', style: 'Growth', issuer: 'Vanguard' },
            'VOOV': { name: 'Vanguard S&P 500 Value ETF', index: 'S&P 500 Value', assetClass: 'US Large Cap', style: 'Value', issuer: 'Vanguard' },
            'SPYV': { name: 'SPDR Portfolio S&P 500 Value ETF', index: 'S&P 500 Value', assetClass: 'US Large Cap', style: 'Value', issuer: 'State Street' },
            
            // Russell 1000 Family - Moderate Risk with S&P 500
            'IWB': { name: 'iShares Russell 1000 ETF', index: 'Russell 1000', assetClass: 'US Large Cap', style: 'Blend', issuer: 'iShares' },
            'IWF': { name: 'iShares Russell 1000 Growth ETF', index: 'Russell 1000 Growth', assetClass: 'US Large Cap', style: 'Growth', issuer: 'iShares' },
            'IWD': { name: 'iShares Russell 1000 Value ETF', index: 'Russell 1000 Value', assetClass: 'US Large Cap', style: 'Value', issuer: 'iShares' },
            
            // Total Market - Low to Moderate Risk
            'VTI': { name: 'Vanguard Total Stock Market ETF', index: 'CRSP US Total Market', assetClass: 'US Total Market', style: 'Blend', issuer: 'Vanguard' },
            'ITOT': { name: 'iShares Core S&P Total US Stock Market ETF', index: 'S&P TMI', assetClass: 'US Total Market', style: 'Blend', issuer: 'iShares' },
            
            // CRSP Large Cap - Low Risk with S&P 500
            'VUG': { name: 'Vanguard Growth ETF', index: 'CRSP US Large Cap Growth', assetClass: 'US Large Cap', style: 'Growth', issuer: 'Vanguard' },
            'VTV': { name: 'Vanguard Value ETF', index: 'CRSP US Large Cap Value', assetClass: 'US Large Cap', style: 'Value', issuer: 'Vanguard' },
            
            // Small Cap
            'IJR': { name: 'iShares Core S&P Small-Cap ETF', index: 'S&P SmallCap 600', assetClass: 'US Small Cap', style: 'Blend', issuer: 'iShares' },
            'VBR': { name: 'Vanguard Small-Cap Value ETF', index: 'CRSP US Small Cap Value', assetClass: 'US Small Cap', style: 'Value', issuer: 'Vanguard' },
            'VB': { name: 'Vanguard Small-Cap ETF', index: 'CRSP US Small Cap', assetClass: 'US Small Cap', style: 'Blend', issuer: 'Vanguard' },
            
            // International
            'VEA': { name: 'Vanguard FTSE Developed Markets ETF', index: 'FTSE Developed All Cap ex US', assetClass: 'International Developed', style: 'Blend', issuer: 'Vanguard' },
            'EFA': { name: 'iShares MSCI EAFE ETF', index: 'MSCI EAFE', assetClass: 'International Developed', style: 'Blend', issuer: 'iShares' },
            'VEU': { name: 'Vanguard FTSE All-World ex-US ETF', index: 'FTSE All-World ex US', assetClass: 'International Total', style: 'Blend', issuer: 'Vanguard' },
            
            // Factor/Strategy ETFs
            'VIG': { name: 'Vanguard Dividend Appreciation ETF', index: 'NASDAQ US Dividend Achievers Select', assetClass: 'US Large Cap', style: 'Dividend Growth', issuer: 'Vanguard' },
            'DVY': { name: 'iShares Select Dividend ETF', index: 'Dow Jones US Select Dividend', assetClass: 'US Large Cap', style: 'High Dividend', issuer: 'iShares' },
            'VYM': { name: 'Vanguard High Dividend Yield ETF', index: 'FTSE High Dividend Yield', assetClass: 'US Large Cap', style: 'High Dividend', issuer: 'Vanguard' }
        };

        // Calculate similarity score between two ETFs (0-100 scale)
        function calculateSimilarityScore(symbol1, symbol2) {
            const etf1 = etfDatabase[symbol1];
            const etf2 = etfDatabase[symbol2];
            
            if (!etf1 || !etf2) return 0; // Unknown ETFs are not similar
            if (symbol1 === symbol2) return 100; // Same ETF
            
            let score = 0;
            
            // Index match (50% weight) - Most important factor
            if (etf1.index === etf2.index) {
                score += 50;
            } else if (etf1.index.includes('S&P 500') && etf2.index.includes('S&P 500')) {
                score += 40; // Same index family
            } else if (etf1.index.includes('Russell 1000') && etf2.index.includes('Russell 1000')) {
                score += 40;
            }
            
            // Asset Class match (20% weight)
            if (etf1.assetClass === etf2.assetClass) {
                score += 20;
            } else if (etf1.assetClass.includes('US Large Cap') && etf2.assetClass.includes('US Large Cap')) {
                score += 15;
            }
            
            // Style match (20% weight)
            if (etf1.style === etf2.style) {
                score += 20;
            } else if ((etf1.style === 'Blend' || etf2.style === 'Blend') && 
                      (etf1.style === 'Growth' || etf1.style === 'Value' || etf2.style === 'Growth' || etf2.style === 'Value')) {
                score += 10;
            }
            
            // Different issuer reduces risk (10% weight reduction)
            if (etf1.issuer !== etf2.issuer) {
                score -= 5;
            }
            
            return Math.min(100, Math.max(0, score));
        }

        // Get risk tier based on similarity score
        function getSimilarityRiskTier(score) {
            if (score >= 90) return { tier: 1, level: 'High Risk', color: 'red', description: 'Presumed Substantially Identical' };
            if (score >= 65) return { tier: 2, level: 'Moderate Risk', color: 'yellow', description: 'User Warning Required' };
            if (score >= 30) return { tier: 3, level: 'Low Risk', color: 'green', description: 'Generally Acceptable' };
            return { tier: 4, level: 'No Risk', color: 'green', description: 'Not Substantially Identical' };
        }

        // Find alternative ETFs to avoid wash sales
        function findWashSaleAlternatives(originalSymbol, targetAssetClass, targetStyle) {
            const alternatives = [];
            const originalETF = etfDatabase[originalSymbol];
            
            if (!originalETF) return alternatives;
            
            for (const [symbol, etf] of Object.entries(etfDatabase)) {
                if (symbol === originalSymbol) continue;
                
                const similarityScore = calculateSimilarityScore(originalSymbol, symbol);
                const riskTier = getSimilarityRiskTier(similarityScore);
                
                // Only suggest alternatives that are low risk (tier 3 or 4)
                if (riskTier.tier >= 3) {
                    // Prefer same asset class and style if specified
                    const assetClassMatch = targetAssetClass ? etf.assetClass === targetAssetClass : true;
                    const styleMatch = targetStyle ? etf.style === targetStyle : true;
                    
                    if (assetClassMatch || styleMatch) {
                        alternatives.push({
                            symbol: symbol,
                            name: etf.name,
                            similarityScore: similarityScore,
                            riskTier: riskTier,
                            assetClass: etf.assetClass,
                            style: etf.style,
                            index: etf.index
                        });
                    }
                }
            }
            
            // Sort by similarity score (ascending) and asset class match
            return alternatives.sort((a, b) => {
                if (targetAssetClass && a.assetClass === targetAssetClass && b.assetClass !== targetAssetClass) return -1;
                if (targetAssetClass && b.assetClass === targetAssetClass && a.assetClass !== targetAssetClass) return 1;
                return a.similarityScore - b.similarityScore;
            }).slice(0, 5); // Return top 5 alternatives
        }

        // --- Event Listeners ---
        costBasisFileInput.addEventListener('change', handleCostBasisFileUpload);
        ytdFileInput.addEventListener('change', handleYtdFileUpload);
        calculateBtn.addEventListener('click', handleCalculation);
        washSaleCheckBtn.addEventListener('click', handleWashSaleCheck);
        exportBtn.addEventListener('click', handleExport);
        
        // Mode switching event listeners
        document.getElementById('taxTargetModeBtn').addEventListener('click', () => switchMode('taxTarget'));
        document.getElementById('cashRaisingModeBtn').addEventListener('click', () => switchMode('cashRaising'));
        proceedToBuyBtn.addEventListener('click', handleProceedToBuy);
        demoWashSaleBtn.addEventListener('click', handleDemoWashSale);
        recommendationsTable.addEventListener('click', handleRowToggle);
        selectAllBtn.addEventListener('click', handleSelectAll);
        deselectAllBtn.addEventListener('click', handleDeselectAll);
        selectAllCheckbox.addEventListener('change', handleSelectAllCheckbox);
        portfolioTable.addEventListener('change', handlePortfolioCheckboxChange);
        portfolioTable.addEventListener('click', handlePortfolioRowToggle);
        portfolioTable.addEventListener('input', handlePriceEdit);
        
        // AI Rationale Event Listeners
        generateAiRationaleBtn.addEventListener('click', handleGenerateAiRationale);
        copyRationaleBtn.addEventListener('click', handleCopyRationale);

        // --- Functions ---
        function handleCostBasisFileUpload(event) {
            const file = event.target.files[0];
            if (!file) {
                costBasisFileNameDisplay.textContent = '';
                return;
            }
            costBasisFileNameDisplay.textContent = `Selected: ${file.name}`;
            const reader = new FileReader();
            reader.onload = (e) => {
                portfolioData = parseCostBasisCSV(e.target.result);
                console.log('Parsed Portfolio Data:', portfolioData);
                if (portfolioData.length > 0) {
                    displayPortfolioHoldings();
                }
            };
            reader.readAsText(file);
        }

        function handleYtdFileUpload(event) {
            const file = event.target.files[0];
            if (!file) {
                ytdFileNameDisplay.textContent = '';
                return;
            }
            ytdFileNameDisplay.textContent = `Selected: ${file.name}`;
            const reader = new FileReader();
            reader.onload = (e) => {
                parseYtdCSV(e.target.result);
            };
            reader.readAsText(file);
        }

        const cleanValue = (val) => {
            if (typeof val !== 'string') return 0;
            const cleaned = val.replace(/[$, "]/g, '');
            if (cleaned.startsWith('(') && cleaned.endsWith(')')) {
                return parseFloat(cleaned.replace(/[()]/g, '')) * -1;
            }
            return parseFloat(cleaned) || 0;
        };

        function findHeaderIndices(header, requiredCols) {
            const indices = {};
            const missingCols = [];
            requiredCols.forEach(col => {
                const index = header.findIndex(h => h.toLowerCase().includes(col.toLowerCase()));
                if (index === -1) {
                    missingCols.push(col);
                }
                indices[col.replace(/[^a-z0-9]/gi, '').toLowerCase()] = index;
            });
            if (missingCols.length > 0) {
                throw new Error(`CSV is missing required columns: ${missingCols.join(', ')}`);
            }
            return indices;
        }

        function parseCostBasisCSV(csvText) {
            const lines = csvText.trim().split('\n');
            if (lines.length < 2) return [];
            const header = lines[0].split(',').map(h => h.trim().replace(/"/g, ''));

            try {
                const requiredCols = ['symbol', 'acquired', 'quantity', 'market value', 'cost basis', 'holding period'];
                const indices = findHeaderIndices(header, requiredCols);

                return lines.slice(1).map(line => {
                    const values = line.split(/,(?=(?:(?:[^"]*"){2})*[^"]*$)/);
                    const symbol = values[indices.symbol]?.trim();
                    if (!symbol || symbol.toLowerCase().includes('total')) return null;

                    const quantity = cleanValue(values[indices.quantity]);
                    const marketValue = cleanValue(values[indices.marketvalue]);
                    const costBasis = cleanValue(values[indices.costbasis]);

                    return {
                        symbol: symbol,
                        acquired: values[indices.acquired]?.trim(),
                        quantity: quantity,
                        marketValue: marketValue,
                        costBasis: costBasis,
                        price: quantity > 0 ? marketValue / quantity : 0,
                        costPerShare: quantity > 0 ? costBasis / quantity : 0,
                        unrealizedGain: marketValue - costBasis,
                        term: values[indices.holdingperiod]?.trim().toLowerCase().includes('long') ? 'Long' : 'Short',
                    };
                }).filter(lot => lot && !isNaN(lot.quantity));
            } catch (error) {
                alert(error.message);
                costBasisFileInput.value = '';
                costBasisFileNameDisplay.textContent = '';
                return [];
            }
        }

        function parseYtdCSV(csvText) {
            const lines = csvText.trim().split('\n');
            if (lines.length < 2) return;
            const header = lines[0].split(',').map(h => h.trim().replace(/"/g, ''));

            try {
                // CRITICAL FIX: More flexible column detection for YTD data
                // Accept both standard columns and alternate column names
                const possibleColumns = {
                    symbol: ['Symbol', 'Security', 'Ticker'],
                    stGain: ['Short Term Realized Gain/(Loss)', 'ST Gain/Loss', 'Short Term G/L', 'Gain/Loss'],
                    ltGain: ['Long Term Realized Gain/(Loss)', 'LT Gain/Loss', 'Long Term G/L']
                };
                
                // Find the best matching column for each type of data
                const indices = {};
                for (const [key, alternatives] of Object.entries(possibleColumns)) {
                    for (const alt of alternatives) {
                        const index = header.findIndex(h => h.toLowerCase().includes(alt.toLowerCase()));
                        if (index !== -1) {
                            indices[key] = index;
                            break;
                        }
                    }
                }
                
                // Check if we found necessary columns
                if (indices.symbol === undefined) {
                    throw new Error('Could not find Symbol column in YTD CSV');
                }
                
                // For simple files that only have a single Gain/Loss column, also check for a Term column
                let termIndex = -1;
                if (indices.stGain === undefined && indices.ltGain === undefined && indices.stGain === indices.ltGain) {
                    termIndex = header.findIndex(h => h.toLowerCase().includes('term'));
                    if (termIndex === -1) {
                        throw new Error('YTD CSV format not recognized. Need either separate ST/LT gain columns or a Term column');
                    }
                    
                    // If we have a term column, find the gain/loss column
                    const gainIndex = header.findIndex(h => 
                        h.toLowerCase().includes('gain') || 
                        h.toLowerCase().includes('loss') || 
                        h.toLowerCase().includes('g/l'));
                    
                    if (gainIndex === -1) {
                        throw new Error('Could not find Gain/Loss column in YTD CSV');
                    }
                    
                    indices.gainLoss = gainIndex;
                }
                
                console.log('YTD CSV column indices:', indices, 'Term index:', termIndex);

                let totalST = 0;
                let totalLT = 0;

                lines.slice(1).forEach(line => {
                    const values = line.split(/,(?=(?:(?:[^"]*"){2})*[^"]*$)/);
                    const symbol = values[indices.symbol]?.trim();
                    if (!symbol || symbol.toLowerCase().includes('total')) {
                        return;
                    }
                    
                    // CRITICAL FIX: Handle different CSV formats
                    if (termIndex !== -1 && indices.gainLoss !== undefined) {
                        // Format with Term column and single Gain/Loss column
                        const term = values[termIndex]?.trim();
                        const gainLoss = cleanValue(values[indices.gainLoss]);
                        
                        if (term && term.toLowerCase().includes('short')) {
                            totalST += gainLoss;
                        } else if (term && (term.toLowerCase().includes('long') || term.toLowerCase().includes('lt'))) {
                            totalLT += gainLoss;
                        } else {
                            console.warn(`Unknown term type: ${term} for ${symbol}, gain: ${gainLoss}`);
                        }
                    } else {
                        // Format with separate ST and LT columns
                        if (indices.stGain !== undefined) {
                            totalST += cleanValue(values[indices.stGain]);
                        }
                        if (indices.ltGain !== undefined) {
                            totalLT += cleanValue(values[indices.ltGain]);
                        }
                    }
                });
                
                // CRITICAL FIX: Add sanity check and debug info
                console.log(`YTD Realized Totals (before auto-fill): ST=${totalST.toFixed(2)}, LT=${totalLT.toFixed(2)}`);
                
                // Safety check - only update if values are numeric and reasonable
                if (!isNaN(totalST) && Math.abs(totalST) < 10000000) {
                    document.getElementById('realizedST').value = totalST.toFixed(2);
                } else {
                    console.error('Invalid ST total calculated:', totalST);
                }
                
                if (!isNaN(totalLT) && Math.abs(totalLT) < 10000000) {
                    document.getElementById('realizedLT').value = totalLT.toFixed(2);
                } else {
                    console.error('Invalid LT total calculated:', totalLT);
                }
                
                console.log(`Auto-filled Realized Gains: ST=${totalST.toFixed(2)}, LT=${totalLT.toFixed(2)}`);
            } catch (error) {
                console.error('Error parsing YTD CSV:', error);
                alert(error.message);
                ytdFileInput.value = '';
                ytdFileNameDisplay.textContent = '';
            }
        }


        function displayPortfolioHoldings() {
            portfolioContainer.classList.remove('hidden');
            portfolioTable.innerHTML = '';

            const formatCurrency = (num) => num.toLocaleString('en-US', { style: 'currency', currency: 'USD' });

            // Add includedInSelling property to each lot (default true)
            portfolioData.forEach((lot, index) => {
                lot.includedInSelling = true;
                lot.lotIndex = index;
            });

            // Group lots by symbol
            const groupedBySymbol = portfolioData.reduce((acc, lot) => {
                if (!acc[lot.symbol]) {
                    acc[lot.symbol] = [];
                }
                acc[lot.symbol].push(lot);
                return acc;
            }, {});

            // Display grouped positions
            for (const symbol in groupedBySymbol) {
                const lots = groupedBySymbol[symbol];
                const totalQuantity = lots.reduce((sum, lot) => sum + lot.quantity, 0);
                const totalMarketValue = lots.reduce((sum, lot) => sum + lot.marketValue, 0);
                const totalCostBasis = lots.reduce((sum, lot) => sum + lot.costBasis, 0);
                const totalUnrealizedGain = totalMarketValue - totalCostBasis;
                const avgPrice = totalQuantity > 0 ? totalMarketValue / totalQuantity : 0;

                // Determine if position has both long and short term lots
                const hasLongTerm = lots.some(lot => lot.term === 'Long');
                const hasShortTerm = lots.some(lot => lot.term === 'Short');
                const termDisplay = hasLongTerm && hasShortTerm ? 'Mixed' : (hasLongTerm ? 'Long' : 'Short');

                // Create parent row for symbol
                const parentRow = document.createElement('tr');
                parentRow.className = 'parent-row font-medium text-gray-800 cursor-pointer';
                parentRow.dataset.symbol = symbol;

                const gainLossClass = totalUnrealizedGain >= 0 ? 'text-green-600' : 'text-red-600';
                const termClass = termDisplay === 'Mixed' ? 'bg-purple-100 text-purple-800' :
                    termDisplay === 'Long' ? 'bg-blue-100 text-blue-800' : 'bg-orange-100 text-orange-800';

                parentRow.innerHTML = `
                    <td class="px-6 py-3 whitespace-nowrap">
                        <div class="flex items-center">
                            <input type="checkbox" class="symbol-checkbox rounded border-gray-300 text-blue-600 focus:ring-blue-500 mr-2" 
                                   data-symbol="${symbol}" checked>
                            <svg class="h-5 w-5 text-gray-400 transition-transform duration-200" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor">
                                <path fill-rule="evenodd" d="M7.293 14.707a1 1 0 010-1.414L10.586 10 7.293 6.707a1 1 0 011.414-1.414l4 4a1 1 0 010 1.414l-4 4a1 1 0 01-1.414 0z" clip-rule="evenodd" />
                            </svg>
                        </div>
                    </td>
                    <td class="px-6 py-3 whitespace-nowrap text-sm font-bold text-gray-900">${symbol}</td>
                    <td class="px-6 py-3 whitespace-nowrap text-sm text-gray-500">${lots.length} lots</td>
                    <td class="px-6 py-3 whitespace-nowrap text-sm text-right font-medium text-gray-900">${totalQuantity.toLocaleString()}</td>
                    <td class="px-6 py-3 whitespace-nowrap text-sm text-right">
                        <input type="number" value="${avgPrice.toFixed(2)}" step="0.01" min="0"
                               class="w-20 px-2 py-1 text-xs text-gray-900 rounded border border-gray-300 text-right price-input"
                               data-symbol="${symbol}" title="Click to edit price">
                    </td>
                    <td class="px-6 py-3 whitespace-nowrap text-sm text-right font-medium text-gray-900">${formatCurrency(totalMarketValue)}</td>
                    <td class="px-6 py-3 whitespace-nowrap text-sm text-right font-medium text-gray-900">${formatCurrency(totalCostBasis)}</td>
                    <td class="px-6 py-3 whitespace-nowrap text-sm text-right font-bold ${gainLossClass}">${formatCurrency(totalUnrealizedGain)}</td>
                    <td class="px-6 py-3 whitespace-nowrap text-center">
                        <span class="px-2 inline-flex text-xs leading-5 font-semibold rounded-full ${termClass}">${termDisplay}</span>
                    </td>
                `;
                portfolioTable.appendChild(parentRow);

                // Create child rows for individual lots
                lots.forEach((lot, lotIndex) => {
                    const childRow = document.createElement('tr');
                    childRow.className = 'child-row hidden';
                    childRow.dataset.parentSymbol = symbol;

                    const lotGainLossClass = lot.unrealizedGain >= 0 ? 'text-green-600' : 'text-red-600';
                    const lotTermClass = lot.term === 'Long' ? 'bg-blue-100 text-blue-800' : 'bg-orange-100 text-orange-800';

                    childRow.innerHTML = `
                        <td class="px-6 py-4 whitespace-nowrap pl-12">
                            <input type="checkbox" class="lot-checkbox rounded border-gray-300 text-blue-600 focus:ring-blue-500" 
                                   data-lot-index="${lot.lotIndex}" data-symbol="${symbol}" checked>
                        </td>
                        <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500 pl-8">${lot.symbol}</td>
                        <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">${lot.acquired}</td>
                        <td class="px-6 py-4 whitespace-nowrap text-sm text-right text-gray-500">${lot.quantity.toLocaleString()}</td>
                        <td class="px-6 py-4 whitespace-nowrap text-sm text-right text-gray-500">${lot.price.toFixed(2)}</td>
                        <td class="px-6 py-4 whitespace-nowrap text-sm text-right text-gray-500">${formatCurrency(lot.marketValue)}</td>
                        <td class="px-6 py-4 whitespace-nowrap text-sm text-right text-gray-500">${formatCurrency(lot.costBasis)}</td>
                        <td class="px-6 py-4 whitespace-nowrap text-sm text-right ${lotGainLossClass}">${formatCurrency(lot.unrealizedGain)}</td>
                        <td class="px-6 py-4 whitespace-nowrap text-center">
                            <span class="px-2 inline-flex text-xs leading-5 font-semibold rounded-full ${lotTermClass}">${lot.term}</span>
                        </td>
                    `;
                    portfolioTable.appendChild(childRow);
                });
            }

            updateSelectionCount();
        }

        function handleSelectAll() {
            const symbolCheckboxes = portfolioTable.querySelectorAll('.symbol-checkbox');
            const lotCheckboxes = portfolioTable.querySelectorAll('.lot-checkbox');

            symbolCheckboxes.forEach(checkbox => {
                checkbox.checked = true;
                const symbol = checkbox.dataset.symbol;
                const symbolRow = checkbox.closest('tr');
                symbolRow.classList.remove('excluded-row');
            });

            lotCheckboxes.forEach(checkbox => {
                checkbox.checked = true;
                const lotIndex = parseInt(checkbox.dataset.lotIndex);
                portfolioData[lotIndex].includedInSelling = true;
                const row = checkbox.closest('tr');
                row.classList.remove('excluded-row');
            });

            selectAllCheckbox.checked = true;
            updateSelectionCount();
        }

        function handleDeselectAll() {
            const symbolCheckboxes = portfolioTable.querySelectorAll('.symbol-checkbox');
            const lotCheckboxes = portfolioTable.querySelectorAll('.lot-checkbox');

            symbolCheckboxes.forEach(checkbox => {
                checkbox.checked = false;
                const symbol = checkbox.dataset.symbol;
                const symbolRow = checkbox.closest('tr');
                symbolRow.classList.add('excluded-row');
            });

            lotCheckboxes.forEach(checkbox => {
                checkbox.checked = false;
                const lotIndex = parseInt(checkbox.dataset.lotIndex);
                portfolioData[lotIndex].includedInSelling = false;
                const row = checkbox.closest('tr');
                row.classList.add('excluded-row');
            });

            selectAllCheckbox.checked = false;
            updateSelectionCount();
        }

        function handleSelectAllCheckbox() {
            const isChecked = selectAllCheckbox.checked;
            const symbolCheckboxes = portfolioTable.querySelectorAll('.symbol-checkbox');
            const lotCheckboxes = portfolioTable.querySelectorAll('.lot-checkbox');

            symbolCheckboxes.forEach(checkbox => {
                checkbox.checked = isChecked;
                const symbolRow = checkbox.closest('tr');
                if (isChecked) {
                    symbolRow.classList.remove('excluded-row');
                } else {
                    symbolRow.classList.add('excluded-row');
                }
            });

            lotCheckboxes.forEach(checkbox => {
                checkbox.checked = isChecked;
                const lotIndex = parseInt(checkbox.dataset.lotIndex);
                portfolioData[lotIndex].includedInSelling = isChecked;
                const row = checkbox.closest('tr');
                if (isChecked) {
                    row.classList.remove('excluded-row');
                } else {
                    row.classList.add('excluded-row');
                }
            });

            updateSelectionCount();
        }

        function handlePortfolioCheckboxChange(event) {
            if (event.target.classList.contains('symbol-checkbox')) {
                const symbol = event.target.dataset.symbol;
                const isChecked = event.target.checked;

                // Update all lots for this symbol
                const symbolLots = portfolioData.filter(lot => lot.symbol === symbol);
                symbolLots.forEach(lot => {
                    lot.includedInSelling = isChecked;
                });

                // Update all lot checkboxes for this symbol
                const lotCheckboxes = portfolioTable.querySelectorAll(`.lot-checkbox[data-symbol="${symbol}"]`);
                lotCheckboxes.forEach(checkbox => {
                    checkbox.checked = isChecked;
                    const row = checkbox.closest('tr');
                    if (isChecked) {
                        row.classList.remove('excluded-row');
                    } else {
                        row.classList.add('excluded-row');
                    }
                });

                // Update symbol row styling
                const symbolRow = event.target.closest('tr');
                if (isChecked) {
                    symbolRow.classList.remove('excluded-row');
                } else {
                    symbolRow.classList.add('excluded-row');
                }

                updateMasterCheckboxState();
                updateSelectionCount();
            }
            else if (event.target.classList.contains('lot-checkbox')) {
                const lotIndex = parseInt(event.target.dataset.lotIndex);
                const symbol = event.target.dataset.symbol;
                portfolioData[lotIndex].includedInSelling = event.target.checked;

                // Update row styling based on selection
                const row = event.target.closest('tr');
                if (event.target.checked) {
                    row.classList.remove('excluded-row');
                } else {
                    row.classList.add('excluded-row');
                }

                // Update symbol checkbox state based on its lots
                const symbolLotCheckboxes = portfolioTable.querySelectorAll(`.lot-checkbox[data-symbol="${symbol}"]`);
                const checkedSymbolLots = Array.from(symbolLotCheckboxes).filter(cb => cb.checked).length;
                const symbolCheckbox = portfolioTable.querySelector(`.symbol-checkbox[data-symbol="${symbol}"]`);

                if (checkedSymbolLots === 0) {
                    symbolCheckbox.checked = false;
                    symbolCheckbox.indeterminate = false;
                    symbolCheckbox.closest('tr').classList.add('excluded-row');
                } else if (checkedSymbolLots === symbolLotCheckboxes.length) {
                    symbolCheckbox.checked = true;
                    symbolCheckbox.indeterminate = false;
                    symbolCheckbox.closest('tr').classList.remove('excluded-row');
                } else {
                    symbolCheckbox.checked = false;
                    symbolCheckbox.indeterminate = true;
                    symbolCheckbox.closest('tr').classList.remove('excluded-row');
                }

                updateMasterCheckboxState();
                updateSelectionCount();
            }
        }

        function updateMasterCheckboxState() {
            const allLotCheckboxes = portfolioTable.querySelectorAll('.lot-checkbox');
            const checkedCount = Array.from(allLotCheckboxes).filter(cb => cb.checked).length;

            if (checkedCount === 0) {
                selectAllCheckbox.checked = false;
                selectAllCheckbox.indeterminate = false;
            } else if (checkedCount === allLotCheckboxes.length) {
                selectAllCheckbox.checked = true;
                selectAllCheckbox.indeterminate = false;
            } else {
                selectAllCheckbox.checked = false;
                selectAllCheckbox.indeterminate = true;
            }
        }

        function handlePortfolioRowToggle(event) {
            const parentRow = event.target.closest('.parent-row');
            if (!parentRow || event.target.type === 'checkbox') return;

            const symbol = parentRow.dataset.symbol;
            const childRows = portfolioTable.querySelectorAll(`tr[data-parent-symbol="${symbol}"]`);
            const arrow = parentRow.querySelector('svg');

            arrow.classList.toggle('icon-rotate');
            childRows.forEach(row => row.classList.toggle('hidden'));
        }

        function updateSelectionCount() {
            const lotCheckboxes = portfolioTable.querySelectorAll('.lot-checkbox');
            const checkedCount = Array.from(lotCheckboxes).filter(cb => cb.checked).length;
            selectedCountSpan.textContent = checkedCount;
            totalCountSpan.textContent = lotCheckboxes.length;
        }

        function handlePriceEdit(event) {
            if (!event.target.classList.contains('price-input')) return;
            
            const symbol = event.target.dataset.symbol;
            const newPrice = parseFloat(event.target.value) || 0;
            
            if (newPrice <= 0) {
                alert('Price must be greater than 0');
                event.target.value = portfolioData.find(lot => lot.symbol === symbol)?.price || 0;
                return;
            }
            
            // Update all lots for this symbol
            let updated = false;
            portfolioData.forEach(lot => {
                if (lot.symbol === symbol) {
                    lot.price = newPrice;
                    lot.marketValue = lot.quantity * newPrice;
                    lot.unrealizedGain = lot.marketValue - lot.costBasis;
                    updated = true;
                }
            });
            
            if (updated) {
                // Refresh the display
                displayPortfolioHoldings();
                
                // Show notification
                const notification = document.createElement('div');
                notification.className = 'fixed top-4 right-4 p-3 bg-green-100 text-green-800 border border-green-200 rounded-lg shadow-lg z-50';
                notification.innerHTML = `
                    <div class="flex items-center">
                        <svg class="h-4 w-4 mr-2" fill="currentColor" viewBox="0 0 20 20">
                            <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clip-rule="evenodd" />
                        </svg>
                        Updated ${symbol} price to $${newPrice.toFixed(2)}
                    </div>
                `;
                document.body.appendChild(notification);
                
                setTimeout(() => {
                    notification.remove();
                }, 3000);
            }
        }

        // Mode switching functionality
        let currentMode = 'taxTarget'; // Default mode
        
        function switchMode(mode) {
            currentMode = mode;
            
            // Update button states
            const taxTargetBtn = document.getElementById('taxTargetModeBtn');
            const cashRaisingBtn = document.getElementById('cashRaisingModeBtn');
            const taxTargetMode = document.getElementById('taxTargetMode');
            const cashRaisingMode = document.getElementById('cashRaisingMode');
            const calculateBtn = document.getElementById('calculateBtn');
            
            if (mode === 'taxTarget') {
                taxTargetBtn.classList.add('active');
                cashRaisingBtn.classList.remove('active');
                taxTargetMode.classList.remove('hidden');
                cashRaisingMode.classList.add('hidden');
                calculateBtn.innerHTML = `
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-2" viewBox="0 0 20 20" fill="currentColor">
                        <path fill-rule="evenodd" d="M6 2a2 2 0 00-2 2v12a2 2 0 002 2h8a2 2 0 002-2V4a2 2 0 00-2-2H6zm1 2a1 1 0 00-1 1v1a1 1 0 001 1h6a1 1 0 001-1V5a1 1 0 00-1-1H7zm6 6a1 1 0 01-1 1H8a1 1 0 110-2h4a1 1 0 011 1zm-3 4a1 1 0 100-2H8a1 1 0 100 2h2z" clip-rule="evenodd" />
                    </svg>
                    Generate Tax Recommendations
                `;
            } else {
                cashRaisingBtn.classList.add('active');
                taxTargetBtn.classList.remove('active');
                cashRaisingMode.classList.remove('hidden');
                taxTargetMode.classList.add('hidden');
                calculateBtn.innerHTML = `
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-2" viewBox="0 0 20 20" fill="currentColor">
                        <path d="M8.433 7.418c.155-.103.346-.196.567-.267v1.698a2.305 2.305 0 01-.567-.267C8.07 8.34 8 8.114 8 8c0-.114.07-.34.433-.582zM11 12.849v-1.698c.22.071.412.164.567.267.364.243.433.468.433.582 0 .114-.07.34-.433.582a2.305 2.305 0 01-.567.267z"/>
                        <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm1-13a1 1 0 10-2 0v.092a4.535 4.535 0 00-1.676.662C6.602 6.234 6 7.009 6 8c0 .99.602 1.765 1.324 2.246.48.32 1.054.545 1.676.662v1.941c-.391-.127-.68-.317-.843-.504a1 1 0 10-1.51 1.31c.562.649 1.413 1.076 2.353 1.253V15a1 1 0 102 0v-.092a4.535 4.535 0 001.676-.662C13.398 13.766 14 12.991 14 12c0-.99-.602-1.765-1.324-2.246A4.535 4.535 0 0011 9.092V7.151c.391.127.68.317.843.504a1 1 0 101.511-1.31c-.563-.649-1.413-1.076-2.354-1.253V5z" clip-rule="evenodd"/>
                    </svg>
                    Generate Cash Raising Plan
                `;
            }
        }

        function handleCalculation() {
            console.log('handleCalculation called');
            if (portfolioData.length === 0) {
                alert('Please upload your Cost Basis CSV file first.');
                return;
            }

            // Check if any positions are selected for selling
            const selectedPositions = portfolioData.filter(lot => lot.includedInSelling);
            console.log('Selected positions:', selectedPositions.length);
            if (selectedPositions.length === 0) {
                alert('Please select at least one position to include in the selling algorithm.');
                return;
            }
            resultsContainer.classList.remove('hidden');
            loader.classList.remove('hidden');
            recommendationsDiv.classList.add('hidden');
            exportBtn.classList.add('hidden');

            const realizedST = parseFloat(document.getElementById('realizedST').value) || 0;
            const realizedLT = parseFloat(document.getElementById('realizedLT').value) || 0;
            
            let neededST, neededLT, targetST, targetLT;
            
            if (currentMode === 'taxTarget') {
                // Tax Target Mode - use specified targets
                targetST = parseFloat(document.getElementById('targetST').value);
                targetLT = parseFloat(document.getElementById('targetLT').value);

                if (isNaN(targetST) || isNaN(targetLT)) {
                    alert('Please enter valid numerical targets for both Short-Term and Long-Term gains.');
                    loader.classList.add('hidden');
                    return;
                }

                neededST = targetST - realizedST;
                neededLT = targetLT - realizedLT;
            } else {
                // Cash Raising Mode - optimize for cash generation
                const cashAmount = parseFloat(document.getElementById('cashAmount').value);
                
                if (isNaN(cashAmount) || cashAmount <= 0) {
                    alert('Please enter a valid cash amount greater than 0.');
                    loader.classList.add('hidden');
                    return;
                }
                
                // For cash raising, we'll use the algorithm to find optimal trades
                // Set targets to undefined to trigger cash raising logic
                targetST = undefined;
                targetLT = undefined;
                neededST = undefined;
                neededLT = undefined;
            }

            setTimeout(() => {
                const excludedPositions = portfolioData.filter(lot => !lot.includedInSelling);
                let analysisResult;
                
                if (currentMode === 'taxTarget') {
                    console.log('Starting tax target calculation with neededST:', neededST, 'neededLT:', neededLT);
                    analysisResult = generateAdvancedRecommendationsWithWashSaleCheck(neededST, neededLT);
                } else {
                    const cashAmount = parseFloat(document.getElementById('cashAmount').value);
                    console.log('Starting cash raising calculation for amount:', cashAmount);
                    analysisResult = generateCashRaisingRecommendations(cashAmount);
                }
                
                console.log('Analysis result:', analysisResult);
                lastRecommendations = analysisResult.recommendations;
                
                // Display results with wash sale warnings
                if (currentMode === 'taxTarget') {
                    displayResultsWithWashSaleAnalysis(analysisResult, { realizedST, realizedLT, targetST, targetLT }, excludedPositions);
                } else {
                    const cashAmount = parseFloat(document.getElementById('cashAmount').value);
                    displayCashRaisingResults(analysisResult, { realizedST, realizedLT, cashAmount }, excludedPositions);
                }
                
                loader.classList.add('hidden');
                recommendationsDiv.classList.remove('hidden');
                if (lastRecommendations.length > 0) {
                    exportBtn.classList.remove('hidden');
                    proceedToBuyBtn.classList.remove('hidden');
                    washSaleCheckBtn.classList.remove('hidden');
                    aiRationaleSection.classList.remove('hidden');
                }
            }, 500);
        }

        // Wash Sale Detection Functions
        function checkWashSaleViolations(recommendations, portfolioHistory = []) {
            const violations = [];
            const today = new Date();
            
            recommendations.forEach(recommendation => {
                if (recommendation.unrealizedGain >= 0) return; // Only check loss positions
                
                const saleDate = new Date(today); // Assume sale today
                const washSalePeriodStart = new Date(saleDate.getTime() - (30 * 24 * 60 * 60 * 1000)); // 30 days before
                const washSalePeriodEnd = new Date(saleDate.getTime() + (30 * 24 * 60 * 60 * 1000)); // 30 days after
                
                // Check against all other positions in portfolio for recent purchases
                portfolioData.forEach(lot => {
                    if (lot.symbol === recommendation.symbol) return; // Skip same symbol
                    
                    const similarityScore = calculateSimilarityScore(recommendation.symbol, lot.symbol);
                    const riskTier = getSimilarityRiskTier(similarityScore);
                    
                    // Flag if high or moderate risk
                    if (riskTier.tier <= 2) {
                        const acquiredDate = new Date(lot.acquired);
                        
                        // Check if acquired within 30 days before sale
                        if (acquiredDate >= washSalePeriodStart && acquiredDate <= saleDate) {
                            violations.push({
                                type: 'lookback',
                                soldSymbol: recommendation.symbol,
                                purchasedSymbol: lot.symbol,
                                saleDate: saleDate.toISOString().split('T')[0],
                                purchaseDate: lot.acquired,
                                similarityScore: similarityScore,
                                riskTier: riskTier,
                                disallowedLoss: Math.abs(recommendation.unrealizedGain),
                                description: `Recently purchased ${lot.symbol} on ${lot.acquired}, which may be substantially identical to ${recommendation.symbol}`
                            });
                        }
                    }
                });
                
                // Check against other recommendations (look-forward check)
                recommendations.forEach(otherRec => {
                    if (otherRec.symbol === recommendation.symbol) return;
                    if (otherRec.unrealizedGain < 0) return; // Only check against purchases (gains or neutral)
                    
                    const similarityScore = calculateSimilarityScore(recommendation.symbol, otherRec.symbol);
                    const riskTier = getSimilarityRiskTier(similarityScore);
                    
                    if (riskTier.tier <= 2) {
                        violations.push({
                            type: 'lookforward',
                            soldSymbol: recommendation.symbol,
                            purchasedSymbol: otherRec.symbol,
                            saleDate: saleDate.toISOString().split('T')[0],
                            purchaseDate: saleDate.toISOString().split('T')[0], // Same day
                            similarityScore: similarityScore,
                            riskTier: riskTier,
                            disallowedLoss: Math.abs(recommendation.unrealizedGain),
                            description: `Planned purchase of ${otherRec.symbol} may be substantially identical to ${recommendation.symbol} being sold`
                        });
                    }
                });
            });
            
            return violations;
        }

        // Helper function to find the best combination of lots to meet a target gain/loss
        function findBestCombination(targetAmount, availableLots) {
            // MIGRATE TO MODULAR ARCHITECTURE
            // First, check if the module is available
            if (window.ModuleRegistry && window.ModuleRegistry.get('algorithm')) {
                console.log('Using modular tax harvesting algorithm');
                const algorithmModule = window.ModuleRegistry.get('algorithm');
                return algorithmModule.findBestCombination(targetAmount, availableLots);
            }
            
            // Fallback to embedded algorithm if module not available
            console.warn('Modular algorithm not available, using embedded version');
            
            console.log('findBestCombination called with target:', targetAmount, 'lots:', availableLots.length);
            if (!availableLots || availableLots.length === 0) return [];
            if (Math.abs(targetAmount) < 0.01) return []; // Target too small
            
            // STRICT TARGET ENFORCEMENT: Set hard limit on maximum allowed total
            // This will be our absolute upper bound to prevent major overshoots
            const STRICT_MAX_LIMIT = Math.abs(targetAmount) * 1.05; // Never exceed target by more than 5%
            
            // Filter and sort lots appropriately
            const relevantLots = availableLots.filter(lot => {
                if (targetAmount > 0) return lot.unrealizedGain > 0; // Need gains
                else return lot.unrealizedGain < 0; // Need losses
            });
            
            if (relevantLots.length === 0) return [];
            
            // Sort by unrealized gain magnitude (largest first for more efficient targeting)
            // This prevents overshooting by selecting fewer, larger positions
            const sortedLots = [...relevantLots].sort((a, b) => {
                if (targetAmount > 0) {
                    return b.unrealizedGain - a.unrealizedGain; // Largest gains first
                } else {
                    return a.unrealizedGain - b.unrealizedGain; // Largest losses first (most negative)
                }
            });
            
            const selectedLots = [];
            let currentAmount = 0;
            
            console.log(`Targeting ${targetAmount > 0 ? 'gains' : 'losses'} of ${Math.abs(targetAmount).toFixed(2)}`);
            
            // Use a greedy approach with strict target adherence
            for (const lot of sortedLots) {
                const remainingNeeded = targetAmount - currentAmount;
                console.log(`\nEvaluating ${lot.symbol}: gain ${lot.unrealizedGain.toFixed(2)}, remaining needed: ${remainingNeeded.toFixed(2)}`);
                
                // Stop if we've already reached the target within tolerance
                if (Math.abs(remainingNeeded) < 0.01) {
                    console.log('Target reached within tolerance, stopping');
                    break;
                }
                
                // Also stop if we've overshot the target
                if ((targetAmount > 0 && currentAmount > targetAmount) ||
                    (targetAmount < 0 && currentAmount < targetAmount)) {
                    console.log('Target exceeded, stopping to prevent further overshooting');
                    break;
                }
                
                // CRITICAL FIX: Enforce absolute maximum limit first
                const lotTotalGain = lot.unrealizedGain;
                const projectedTotal = currentAmount + lotTotalGain;
                
                // Immediate rejection if this lot would cause us to exceed our strict max limit
                if (Math.abs(projectedTotal) > STRICT_MAX_LIMIT) {
                    console.log(`⛔ STRICT LIMIT: Adding ${lot.symbol} would exceed maximum allowed total (${STRICT_MAX_LIMIT.toFixed(2)}), skipping`);
                    break; // Break the entire loop - we're too close to limit
                }
                
                const targetExceedance = Math.abs(projectedTotal - targetAmount);
                
                // Progressive tolerance - stricter for larger targets
                let tolerancePercent = 0.02; // 2% baseline tolerance (reduced from 3%)
                if (Math.abs(targetAmount) > 50000) {
                    // For large targets (>$50k), use even stricter tolerance
                    tolerancePercent = 0.01; // 1% for large targets
                }
                const targetTolerance = Math.abs(targetAmount) * tolerancePercent;
                
                // If adding the whole lot stays within reasonable bounds, add it
                if ((targetAmount > 0 && projectedTotal <= targetAmount) ||
                    (targetAmount < 0 && projectedTotal >= targetAmount)) {
                    
                    // Add extra check to avoid crossing the target boundary 
                    // when we're already close to target
                    const currentProximity = Math.abs(currentAmount / targetAmount);
                    if (currentProximity > 0.9 && // Already at 90%+ of target
                       ((targetAmount > 0 && projectedTotal > targetAmount) ||
                        (targetAmount < 0 && projectedTotal < targetAmount))) {
                        console.log(`✗ Skipping whole lot - would cross target when already close`);
                    } else {
                        selectedLots.push({
                            ...lot,
                            sharesToSell: lot.quantity,
                            actualGain: lotTotalGain,
                            proceeds: (lot.price * lot.quantity),
                            reason: targetAmount > 0 ? 'Tax Gain Harvesting' : 'Tax Loss Harvesting'
                        });
                        
                        currentAmount = projectedTotal;
                        console.log(`✓ Added whole lot: ${lot.symbol}, gain: ${lotTotalGain.toFixed(2)}, running total: ${currentAmount.toFixed(2)}`);
                    }
                    
                } else if (targetExceedance <= targetTolerance && 
                          // CRITICAL FIX: Much stricter threshold - only allow exceeding if we're below 90% of target
                          Math.abs(currentAmount) < Math.abs(targetAmount) * 0.90) {
                    
                    // CRITICAL CHECK: Enforce the absolute maximum limit
                    if (Math.abs(projectedTotal) > STRICT_MAX_LIMIT) {
                        console.log(`⛔ STRICT LIMIT: Adding ${lot.symbol} would exceed maximum allowed total (${STRICT_MAX_LIMIT.toFixed(2)}), skipping`);
                        break; // Exit the loop entirely
                    }
                    
                    // Extra check - if target is large and we're already close, be extra cautious
                    if (Math.abs(targetAmount) > 50000 && Math.abs(currentAmount) > Math.abs(targetAmount) * 0.75) {
                        // For large targets when already near 75%, check if exceeding by more than 0.5%
                        if (targetExceedance > Math.abs(targetAmount) * 0.005) {
                            console.log(`✗ Skipping lot - too much overshoot for a large target already near completion`);
                            break; // Stop here to avoid overshooting large targets
                        }
                    }
                    
                    // If overshoot is within tolerance and we haven't already reached close to target, add the whole lot
                    selectedLots.push({
                        ...lot,
                        sharesToSell: lot.quantity,
                        actualGain: lotTotalGain,
                        proceeds: (lot.price * lot.quantity),
                        reason: targetAmount > 0 ? 'Tax Gain Harvesting' : 'Tax Loss Harvesting'
                    });
                    
                    currentAmount = projectedTotal;
                    console.log(`✓ Added whole lot (within tolerance): ${lot.symbol}, gain: ${lotTotalGain.toFixed(2)}, running total: ${currentAmount.toFixed(2)}`);
                    break; // Stop here as we're close enough
                    
                } else {
                    // Try partial shares for more precision
                    const lotGainPerShare = lot.unrealizedGain / lot.quantity;
                    
                    if (Math.abs(lotGainPerShare) > 0.001) { // Meaningful gain per share
                        const sharesNeeded = Math.abs(remainingNeeded / lotGainPerShare);
                        let idealShares = Math.floor(sharesNeeded);
                        
                        // Ensure we have at least 1 share but not more than available
                        idealShares = Math.max(1, Math.min(idealShares, lot.quantity));
                        
                        // Only proceed if it's a reasonable number of shares (at least 1% of position)
                        const minShares = Math.max(1, Math.ceil(lot.quantity * 0.01));
                        
                        if (idealShares >= minShares && idealShares < lot.quantity) {
                            const actualGain = lotGainPerShare * idealShares;
                            const newTotal = currentAmount + actualGain;
                            
                            // Ensure partial addition doesn't overshoot
                            const partialExceedance = (targetAmount > 0) ? 
                                Math.max(0, newTotal - targetAmount) : 
                                Math.max(0, targetAmount - newTotal);
                            
                            // More strict tolerance for partial lots, especially large targets
                            let partialTolerance;
                            if (Math.abs(targetAmount) > 75000) {
                                partialTolerance = targetTolerance * 0.5; // Half the normal tolerance for large targets
                            } else {
                                partialTolerance = targetTolerance * 0.75; // 75% of normal tolerance otherwise
                            }
                            
                            // Only allow partial selling if it gets us closer to target
                            const currentDistance = Math.abs(targetAmount - currentAmount);
                            const newDistance = Math.abs(targetAmount - newTotal);
                            
                            // More stringent conditions for partial lot inclusion
                            if (newDistance < currentDistance && partialExceedance <= partialTolerance) {
                                selectedLots.push({
                                    ...lot,
                                    sharesToSell: idealShares,
                                    actualGain: actualGain,
                                    proceeds: (lot.price * idealShares),
                                    reason: targetAmount > 0 ? 'Tax Gain Harvesting' : 'Tax Loss Harvesting'
                                });
                                
                                currentAmount = newTotal;
                                console.log(`✓ Added partial lot: ${lot.symbol}, shares: ${idealShares}/${lot.quantity}, gain: ${actualGain.toFixed(2)}, running total: ${currentAmount.toFixed(2)}`);
                            } else {
                                console.log(`✗ Partial lot would overshoot or not improve accuracy, skipping`);
                            }
                        }
                    }
                    
                    // After trying partial, stop the loop to avoid further overshooting
                    break;
                }
                
                // CRITICAL FIX: Much stricter early termination threshold
                if ((targetAmount > 0 && currentAmount >= targetAmount * 0.90) || // Stop at 90% of target for positive targets
                    (targetAmount < 0 && currentAmount <= targetAmount * 0.90)) { // Stop at 90% of target for negative targets
                    console.log('⚠️ EARLY TERMINATION: Target reached 90%+ of goal, stopping to prevent overshooting');
                    break;
                }
                
                // CRITICAL FIX: Check against strict maximum limit
                if (Math.abs(currentAmount) > STRICT_MAX_LIMIT * 0.95) { // If we're at 95% of our strict limit
                    console.log(`⛔ STRICT LIMIT: Already at ${(Math.abs(currentAmount)/STRICT_MAX_LIMIT*100).toFixed(1)}% of maximum allowed total (${STRICT_MAX_LIMIT.toFixed(2)}), halting immediately`);
                    break;
                }
                
                // Additional safety checks with progressive thresholds based on target size
                const currentExceedance = Math.abs(currentAmount - targetAmount);
                let maxExceedancePercent = 0.015; // 1.5% default (reduced from 3%)
                
                // For larger targets, use even stricter thresholds
                if (Math.abs(targetAmount) > 50000) {
                    maxExceedancePercent = 0.01; // 1% for large targets
                }
                if (Math.abs(targetAmount) > 100000) {
                    maxExceedancePercent = 0.005; // 0.5% for very large targets
                }
                
                if (currentExceedance > Math.abs(targetAmount) * maxExceedancePercent) {
                    console.log(`⚠️ Exceeding target by more than ${(maxExceedancePercent*100).toFixed(1)}%, halting immediately`);
                    break;
                }
            }
            
            const finalTotal = selectedLots.reduce((sum, lot) => sum + lot.actualGain, 0);
            const accuracy = Math.abs(finalTotal - targetAmount);
            const accuracyPercent = (accuracy / Math.abs(targetAmount)) * 100;
            
            console.log(`\n=== findBestCombination Results ===`);
            console.log(`Target: ${targetAmount.toFixed(2)}`);
            console.log(`Actual: ${finalTotal.toFixed(2)}`);
            console.log(`Accuracy: ${accuracy.toFixed(2)} (${accuracyPercent.toFixed(1)}% off target)`);
            console.log(`Selected ${selectedLots.length} lots`);
            
            return selectedLots;
        }

        // Basic recommendation function without wash sale checks
        function generateAdvancedRecommendations(neededST, neededLT) {
            console.log('generateAdvancedRecommendations called with:', neededST, neededLT);
            
            // CRITICAL FIX: If targets are very close to current values, don't do anything
            // This prevents the algorithm from trying to find tiny adjustments
            if (Math.abs(neededST) < 100 && Math.abs(neededLT) < 100) {
                console.log('Targets are very close to current values, no action needed');
                return [];
            }
            
            // CRITICAL FIX: Use the modular architecture if available
            if (window.ModuleRegistry && window.ModuleRegistry.get('algorithm')) {
                console.log('Using modular tax harvesting algorithm for advanced recommendations');
                const algorithmModule = window.ModuleRegistry.get('algorithm');
                
                // EMERGENCY FIX: Use the new interface with params object
                const ytdGains = {
                    shortTerm: parseFloat(document.getElementById('realizedST').value) || 0,
                    longTerm: parseFloat(document.getElementById('realizedLT').value) || 0
                };
                
                const taxTargets = {
                    shortTerm: parseFloat(document.getElementById('targetST').value) || 0,
                    longTerm: parseFloat(document.getElementById('targetLT').value) || 0
                };
                
                const params = {
                    positions: portfolioData,
                    taxTargets: taxTargets,
                    ytdGains: ytdGains
                };
                
                console.log('Calling algorithm with params:', params);
                
                // Get results from algorithm
                const result = algorithmModule.generateRecommendations(params);
                
                // Check if we got a result with the new format
                if (result && result.selectedPositions) {
                    console.log('EMERGENCY: New format result received:', result);
                    return result.selectedPositions;
                } else {
                    // Fall back to old format call
                    console.log('EMERGENCY: New format failed, trying legacy format');
                    return algorithmModule.generateRecommendations(neededST, neededLT, portfolioData);
                }
            }
            
            // Fallback to embedded algorithm
            console.warn('Modular algorithm not available, using embedded version');
            
            const lots = portfolioData.filter(lot => lot.includedInSelling);
            console.log('Available lots for trading:', lots.length);
            const recommendationsArray = [];

            // Separate into categories
            const stGains = lots.filter(l => l.term === 'Short' && l.unrealizedGain > 0);
            const stLosses = lots.filter(l => l.term === 'Short' && l.unrealizedGain < 0);
            const ltGains = lots.filter(l => l.term === 'Long' && l.unrealizedGain > 0);
            const ltLosses = lots.filter(l => l.term === 'Long' && l.unrealizedGain < 0);

            console.log('Categories - ST Gains:', stGains.length, 'ST Losses:', stLosses.length, 'LT Gains:', ltGains.length, 'LT Losses:', ltLosses.length);
            
            // MIGRATE TO MODULAR ARCHITECTURE
            // Check if the module is available for generating recommendations
            if (window.ModuleRegistry && window.ModuleRegistry.get('algorithm')) {
                console.log('Using modular tax harvesting algorithm for recommendations');
                const algorithmModule = window.ModuleRegistry.get('algorithm');
                return algorithmModule.generateRecommendations(neededST, neededLT, lots);
            }
            
            // Fallback to embedded algorithm if module not available
            console.warn('Modular algorithm not available for recommendations, using embedded version');
            
            // CRITICAL FIX: Check for excessive targets and cap them
            const capTarget = (target) => {
                // For gains, don't exceed 105% of target
                // For losses, don't go below 105% of target
                const maxMultiplier = 1.05;
                if (target > 0) {
                    return Math.min(target, target * maxMultiplier);
                } else {
                    return Math.max(target, target * maxMultiplier);
                }
            };
            
            // Apply caps to targets
            const cappedSTTarget = capTarget(neededST);
            const cappedLTTarget = capTarget(neededLT);
            
            console.log(`Original ST Target: ${neededST}, Capped: ${cappedSTTarget}`);
            console.log(`Original LT Target: ${neededLT}, Capped: ${cappedLTTarget}`);

            if (cappedSTTarget > 0) recommendationsArray.push(...findBestCombination(cappedSTTarget, stGains));
            else if (cappedSTTarget < 0) recommendationsArray.push(...findBestCombination(cappedSTTarget, stLosses));

            if (cappedLTTarget > 0) recommendationsArray.push(...findBestCombination(cappedLTTarget, ltGains));
            else if (cappedLTTarget < 0) recommendationsArray.push(...findBestCombination(cappedLTTarget, ltLosses));

            console.log('Generated recommendations:', recommendationsArray.length);
            return recommendationsArray;
        }

        // Enhanced recommendation function with wash sale avoidance
        function generateAdvancedRecommendationsWithWashSaleCheck(neededST, neededLT) {
            // Get initial recommendations
            const initialRecommendations = generateAdvancedRecommendations(neededST, neededLT);
            
            // Check for wash sale violations
            const violations = checkWashSaleViolations(initialRecommendations);
            
            // If no violations, return original recommendations
            if (violations.length === 0) {
                return {
                    recommendations: initialRecommendations,
                    violations: [],
                    alternatives: []
                };
            }
            
            // Generate alternatives for violated positions
            const alternatives = [];
            violations.forEach(violation => {
                const soldETF = etfDatabase[violation.soldSymbol];
                const purchasedETF = etfDatabase[violation.purchasedSymbol];
                
                if (soldETF && purchasedETF) {
                    const alternativeETFs = findWashSaleAlternatives(
                        violation.purchasedSymbol, 
                        purchasedETF.assetClass, 
                        purchasedETF.style
                    );
                    
                    alternatives.push({
                        violatedSymbol: violation.purchasedSymbol,
                        soldSymbol: violation.soldSymbol,
                        riskTier: violation.riskTier,
                        alternatives: alternativeETFs
                    });
                }
            });
            
            return {
                recommendations: initialRecommendations,
                violations: violations,
                alternatives: alternatives
            };
        }

        // Advanced Cash Raising Mode - Sophisticated algorithm with tax thresholds
        function generateCashRaisingRecommendations(cashAmount) {
            console.log('=== ADVANCED CASH RAISING ALGORITHM ===');
            console.log('Cash target:', cashAmount);
            
            // Get threshold parameters with error handling
            const maxSTGain = parseFloat(document.getElementById('maxSTGain').value) || Infinity;
            const maxLTGain = parseFloat(document.getElementById('maxLTGain').value) || Infinity;
            const minSTLoss = parseFloat(document.getElementById('minSTLoss').value) || -Infinity;
            const minLTLoss = parseFloat(document.getElementById('minLTLoss').value) || -Infinity;
            
            // Get strategy with fallback
            const strategyElement = document.querySelector('input[name="cashStrategy"]:checked');
            const strategy = strategyElement ? strategyElement.value : 'minimize_tax';
            
            console.log('Strategy element found:', !!strategyElement);
            
            console.log('Tax thresholds:', { maxSTGain, maxLTGain, minSTLoss: -Math.abs(minSTLoss), minLTLoss: -Math.abs(minLTLoss) });
            console.log('Strategy:', strategy);
            
            // Get all available positions
            const availablePositions = portfolioData.filter(lot => lot.includedInSelling);
            console.log('Available positions:', availablePositions.length);
            
            if (availablePositions.length === 0) {
                return {
                    recommendations: [],
                    violations: [],
                    alternatives: [],
                    summary: {
                        totalCashRaised: 0,
                        totalGainLoss: 0,
                        shortTermGainLoss: 0,
                        longTermGainLoss: 0,
                        cashTarget: cashAmount,
                        cashExcess: -cashAmount,
                        thresholdsMet: false,
                        strategy: strategy
                    }
                };
            }
            
            // Process and categorize positions with error handling
            const processedPositions = [];
            
            for (const lot of availablePositions) {
                try {
                    const currentPrice = parseFloat(lot.currentPrice || lot.price || 0);
                    const costBasis = parseFloat(lot.costBasis || lot.costPerShare || 0);
                    const quantity = parseFloat(lot.quantity || 0);
                    
                    if (currentPrice <= 0 || quantity <= 0) {
                        console.warn('Skipping position with invalid price/quantity:', lot.symbol, { currentPrice, quantity });
                        continue;
                    }
                    
                    const gainLoss = (currentPrice - costBasis) * quantity;
                    const marketValue = currentPrice * quantity;
                    const isLongTerm = lot.term === 'Long-Term' || lot.term === 'Long';
                    
                    processedPositions.push({
                        ...lot,
                        currentPrice,
                        costBasis,
                        quantity,
                        gainLoss,
                        marketValue,
                        isLongTerm,
                        isShortTerm: !isLongTerm,
                        isGain: gainLoss > 0,
                        isLoss: gainLoss < 0
                    });
                } catch (error) {
                    console.error('Error processing position:', lot.symbol, error);
                }
            }
            
            console.log('Processed positions:', processedPositions.length);
            
            // Categorize positions
            const categories = {
                stLosses: processedPositions.filter(p => p.isShortTerm && p.isLoss),
                ltLosses: processedPositions.filter(p => p.isLongTerm && p.isLoss),
                ltGains: processedPositions.filter(p => p.isLongTerm && p.isGain),
                stGains: processedPositions.filter(p => p.isShortTerm && p.isGain)
            };
            
            console.log('Position categories:', {
                stLosses: categories.stLosses.length,
                ltLosses: categories.ltLosses.length,
                ltGains: categories.ltGains.length,
                stGains: categories.stGains.length
            });
            
            // Sort each category by strategy with error handling
            const sortByStrategy = (positions, category) => {
                try {
                    console.log(`Sorting ${positions.length} positions for category ${category} with strategy ${strategy}`);
                    
                    switch (strategy) {
                        case 'minimize_tax':
                            if (category.includes('Loss')) {
                                // For losses: prioritize larger losses (better tax benefit)
                                return positions.sort((a, b) => a.gainLoss - b.gainLoss);
                            } else {
                                // For gains: prioritize smaller gains (less tax impact)
                                return positions.sort((a, b) => a.gainLoss - b.gainLoss);
                            }
                        case 'maximize_cash':
                            // Prioritize larger positions for maximum cash
                            return positions.sort((a, b) => b.marketValue - a.marketValue);
                        case 'balanced':
                        default:
                            // Balance between tax efficiency and cash generation
                            return positions.sort((a, b) => {
                                try {
                                    const aScore = (a.marketValue / 1000) + (a.isLoss ? Math.abs(a.gainLoss) / 100 : -a.gainLoss / 100);
                                    const bScore = (b.marketValue / 1000) + (b.isLoss ? Math.abs(b.gainLoss) / 100 : -b.gainLoss / 100);
                                    return bScore - aScore;
                                } catch (sortError) {
                                    console.error('Error in balanced sort:', sortError, { a, b });
                                    return 0;
                                }
                            });
                    }
                } catch (error) {
                    console.error('Error in sortByStrategy:', error);
                    return positions; // Return unsorted if error
                }
            };
            
            // Sort all categories
            categories.stLosses = sortByStrategy(categories.stLosses, 'stLosses');
            categories.ltLosses = sortByStrategy(categories.ltLosses, 'ltLosses');
            categories.ltGains = sortByStrategy(categories.ltGains, 'ltGains');
            categories.stGains = sortByStrategy(categories.stGains, 'stGains');
            
            // Advanced selection algorithm with constraint satisfaction
            const selectedPositions = [];
            let totalCashRaised = 0;
            let currentSTGain = 0;
            let currentLTGain = 0;
            let currentSTLoss = 0;
            let currentLTLoss = 0;
            
            // Priority order based on tax efficiency
            const selectionOrder = [
                { category: 'stLosses', name: 'Short-Term Losses' },
                { category: 'ltLosses', name: 'Long-Term Losses' },
                { category: 'ltGains', name: 'Long-Term Gains' },
                { category: 'stGains', name: 'Short-Term Gains' }
            ];
            
            console.log('=== SELECTION PROCESS ===');
            
            let selectionCount = 0;
            const maxSelections = 1000; // Prevent infinite loops
            
            for (const { category, name } of selectionOrder) {
                console.log(`Processing ${name}:`, categories[category].length, 'positions');
                
                for (const position of categories[category]) {
                    selectionCount++;
                    if (selectionCount > maxSelections) {
                        console.error('Selection process exceeded maximum iterations, breaking');
                        break;
                    }
                    
                    try {
                        // Calculate what the new totals would be
                        const newCashRaised = totalCashRaised + (position.marketValue || 0);
                        
                        // Check if adding this position would exceed target by more than 1%
                        const maxAcceptableCash = cashAmount * 1.01; // Allow 1% overage
                        if (newCashRaised > maxAcceptableCash) {
                            console.log(`Skipping ${position.symbol}: would exceed cash target by too much ($${newCashRaised.toFixed(0)} > $${maxAcceptableCash.toFixed(0)})`);
                            continue;
                        }
                        
                        // Check if we've already met our cash target
                        if (totalCashRaised >= cashAmount) {
                            console.log('Cash target already met, stopping selection');
                            break;
                        }
                        
                        const newSTGain = currentSTGain + (position.isShortTerm && position.isGain ? (position.gainLoss || 0) : 0);
                        const newLTGain = currentLTGain + (position.isLongTerm && position.isGain ? (position.gainLoss || 0) : 0);
                        const newSTLoss = currentSTLoss + (position.isShortTerm && position.isLoss ? (position.gainLoss || 0) : 0);
                        const newLTLoss = currentLTLoss + (position.isLongTerm && position.isLoss ? (position.gainLoss || 0) : 0);
                        
                        // Check threshold constraints with safe comparisons
                        const withinSTGainLimit = isFinite(maxSTGain) ? newSTGain <= maxSTGain : true;
                        const withinLTGainLimit = isFinite(maxLTGain) ? newLTGain <= maxLTGain : true;
                        const withinSTLossLimit = isFinite(minSTLoss) ? newSTLoss >= -Math.abs(minSTLoss) : true;
                        const withinLTLossLimit = isFinite(minLTLoss) ? newLTLoss >= -Math.abs(minLTLoss) : true;
                        
                        const meetsAllConstraints = withinSTGainLimit && withinLTGainLimit && withinSTLossLimit && withinLTLossLimit;
                        
                        if (meetsAllConstraints) {
                            selectedPositions.push(position);
                            totalCashRaised = newCashRaised;
                            currentSTGain = newSTGain;
                            currentLTGain = newLTGain;
                            currentSTLoss = newSTLoss;
                            currentLTLoss = newLTLoss;
                            
                            console.log(`Selected ${position.symbol}: $${(position.marketValue || 0).toFixed(0)} cash, $${(position.gainLoss || 0).toFixed(0)} gain/loss`);
                        } else {
                            console.log(`Skipped ${position.symbol}: would violate constraints`);
                        }
                    } catch (constraintError) {
                        console.error('Error checking constraints for position:', position.symbol, constraintError);
                    }
                }
                
                if (totalCashRaised >= cashAmount || selectionCount > maxSelections) break;
            }
            
            console.log(`Selection completed after ${selectionCount} iterations`);
            
            // If we haven't reached the target, try to get closer with remaining positions
            if (totalCashRaised < cashAmount) {
                console.log('=== TRYING TO GET CLOSER TO CASH TARGET ===');
                console.log(`Current: $${totalCashRaised.toFixed(0)}, Target: $${cashAmount.toFixed(0)}, Shortfall: $${(cashAmount - totalCashRaised).toFixed(0)}`);
                
                const remainingPositions = processedPositions.filter(p => !selectedPositions.includes(p));
                const shortfall = cashAmount - totalCashRaised;
                const maxAcceptableOverage = cashAmount * 0.01; // 1% overage
                
                // Sort by how close they get us to the target without going over too much
                const sortedRemaining = remainingPositions.sort((a, b) => {
                    const aOverage = Math.max(0, a.marketValue - shortfall);
                    const bOverage = Math.max(0, b.marketValue - shortfall);
                    
                    // If both would cause acceptable overage, prefer the one with better tax efficiency
                    if (aOverage <= maxAcceptableOverage && bOverage <= maxAcceptableOverage) {
                        const aTaxEfficiency = Math.abs(a.gainLoss) / a.marketValue;
                        const bTaxEfficiency = Math.abs(b.gainLoss) / b.marketValue;
                        return aTaxEfficiency - bTaxEfficiency;
                    }
                    
                    // Otherwise, prefer the one that gets us closer without excessive overage
                    return aOverage - bOverage;
                });
                
                for (const position of sortedRemaining) {
                    const newTotal = totalCashRaised + position.marketValue;
                    const overage = newTotal - cashAmount;
                    const overagePercent = (overage / cashAmount) * 100;
                    
                    // Only add if overage is acceptable (≤1%) or if we're still short
                    if (overage <= 0 || overagePercent <= 1.0) {
                        selectedPositions.push(position);
                        totalCashRaised = newTotal;
                        
                        if (position.isShortTerm && position.isGain) currentSTGain += position.gainLoss;
                        if (position.isLongTerm && position.isGain) currentLTGain += position.gainLoss;
                        if (position.isShortTerm && position.isLoss) currentSTLoss += position.gainLoss;
                        if (position.isLongTerm && position.isLoss) currentLTLoss += position.gainLoss;
                        
                        console.log(`Added ${position.symbol}: $${position.marketValue.toFixed(0)} cash (${overagePercent.toFixed(1)}% overage)`);
                        
                        // Stop if we're close enough to target
                        if (totalCashRaised >= cashAmount) break;
                    } else {
                        console.log(`Skipped ${position.symbol}: would cause ${overagePercent.toFixed(1)}% overage`);
                    }
                }
            }
            
            // Calculate final metrics
            const totalGainLoss = currentSTGain + currentLTGain + currentSTLoss + currentLTLoss;
            const thresholdsMet = (
                currentSTGain <= maxSTGain &&
                currentLTGain <= maxLTGain &&
                currentSTLoss >= -Math.abs(minSTLoss) &&
                currentLTLoss >= -Math.abs(minLTLoss)
            );
            
            console.log('=== FINAL RESULTS ===');
            console.log('Cash raised:', totalCashRaised.toFixed(0), 'Target:', cashAmount);
            console.log('ST Gain:', currentSTGain.toFixed(0), 'Limit:', maxSTGain);
            console.log('LT Gain:', currentLTGain.toFixed(0), 'Limit:', maxLTGain);
            console.log('ST Loss:', currentSTLoss.toFixed(0), 'Min:', -Math.abs(minSTLoss));
            console.log('LT Loss:', currentLTLoss.toFixed(0), 'Min:', -Math.abs(minLTLoss));
            console.log('Thresholds met:', thresholdsMet);
            
            // Define formatting function first
            const formatCurrencyWithSign = (num) => num.toLocaleString('en-US', { style: 'currency', currency: 'USD', signDisplay: 'auto' });
            
            // Convert to recommendation format
            const recommendations = selectedPositions.map(position => ({
                symbol: position.symbol || 'Unknown',
                quantity: position.quantity || 0,
                currentPrice: position.currentPrice || 0,
                costBasis: (position.costBasis || 0) * (position.quantity || 0), // Total cost basis
                costPerShare: position.costBasis || 0, // Per-share cost basis
                price: position.currentPrice || 0,
                marketValue: position.marketValue || 0,
                unrealizedGain: position.gainLoss || 0,
                term: position.isLongTerm ? 'Long-Term' : 'Short-Term',
                acquired: position.acquiredDate || position.acquired || 'Unknown',
                acquiredDate: position.acquiredDate || position.acquired || 'Unknown',
                reason: position.isLoss ? 
                    `Tax loss harvesting (${formatCurrencyWithSign(position.gainLoss || 0)})` :
                    `Cash generation (${formatCurrencyWithSign(position.gainLoss || 0)} ${position.isLongTerm ? 'long-term' : 'short-term'} gain)`
            }));
            
            console.log('Generated recommendations:', recommendations.length);
            
            // Check for wash sale violations
            let violations = [];
            let alternatives = [];
            
            try {
                violations = checkWashSaleViolations(recommendations);
                alternatives = violations.length > 0 ? 
                    violations.map(v => findWashSaleAlternatives(v.symbol)).flat() : [];
            } catch (error) {
                console.error('Error in wash sale detection:', error);
                violations = [];
                alternatives = [];
            }
            
            console.log(`Cash raising: Selected ${recommendations.length} positions for $${totalCashRaised.toFixed(2)} cash`);
            console.log(`Tax impact: ST ${formatCurrencyWithSign(currentSTGain + currentSTLoss)}, LT ${formatCurrencyWithSign(currentLTGain + currentLTLoss)}`);
            
            // Debug: Log each recommendation for verification
            recommendations.forEach(rec => {
                const calculatedGainLoss = rec.marketValue - rec.costBasis;
                console.log(`${rec.symbol}: ${rec.quantity} shares @ $${rec.currentPrice.toFixed(2)}`);
                console.log(`  Market Value: $${rec.marketValue.toFixed(2)}`);
                console.log(`  Cost Basis: $${rec.costBasis.toFixed(2)} (${rec.costPerShare.toFixed(2)} per share)`);
                console.log(`  Calculated Gain/Loss: $${calculatedGainLoss.toFixed(2)}`);
                console.log(`  Stored Gain/Loss: $${rec.unrealizedGain.toFixed(2)}`);
                if (Math.abs(calculatedGainLoss - rec.unrealizedGain) > 1) {
                    console.warn(`  ⚠️ MISMATCH: Calculated vs Stored gain/loss differs by $${(calculatedGainLoss - rec.unrealizedGain).toFixed(2)}`);
                }
            });
            
            return {
                recommendations,
                violations,
                alternatives,
                summary: {
                    totalCashRaised,
                    totalGainLoss,
                    shortTermGainLoss: currentSTGain + currentSTLoss,
                    longTermGainLoss: currentLTGain + currentLTLoss,
                    stGain: currentSTGain,
                    ltGain: currentLTGain,
                    stLoss: currentSTLoss,
                    ltLoss: currentLTLoss,
                    cashTarget: cashAmount,
                    cashExcess: totalCashRaised - cashAmount,
                    thresholdsMet,
                    strategy,
                    constraints: {
                        maxSTGain,
                        maxLTGain,
                        minSTLoss: -Math.abs(minSTLoss),
                        minLTLoss: -Math.abs(minLTLoss)
                    }
                }
            };
        }

        // Enhanced display function with wash sale analysis
        function displayResultsWithWashSaleAnalysis(analysisResult, targets, excludedPositions = []) {
            const { recommendations, violations, alternatives } = analysisResult;
            
            // First display standard results
            displayResults(recommendations, targets, excludedPositions);
            
            // Add wash sale warnings if any violations found
            if (violations.length > 0) {
                displayWashSaleWarnings(violations, alternatives);
            }
        }

        // Display cash raising results
        function displayCashRaisingResults(analysisResult, targets, excludedPositions = []) {
            const { recommendations, violations, alternatives, summary } = analysisResult;
            
            // Create custom targets object for cash raising mode
            const cashTargets = {
                realizedST: targets.realizedST,
                realizedLT: targets.realizedLT,
                targetST: summary.shortTermGainLoss + targets.realizedST, // Final ST after trades
                targetLT: summary.longTermGainLoss + targets.realizedLT,  // Final LT after trades
                cashAmount: targets.cashAmount,
                cashRaised: summary.totalCashRaised,
                cashExcess: summary.cashExcess,
                thresholdsMet: summary.thresholdsMet,
                strategy: summary.strategy,
                constraints: summary.constraints,
                stGain: summary.stGain,
                ltGain: summary.ltGain,
                stLoss: summary.stLoss,
                ltLoss: summary.ltLoss,
                mode: 'cashRaising'
            };
            
            // Display standard results with cash raising context
            displayResults(recommendations, cashTargets, excludedPositions);
            
            // Add wash sale warnings if any violations found
            if (violations.length > 0) {
                displayWashSaleWarnings(violations, alternatives);
            }
        }

        // Display wash sale warnings and alternatives
        function displayWashSaleWarnings(violations, alternatives) {
            // Create wash sale warnings section if it doesn't exist
            let washSaleSection = document.getElementById('wash-sale-analysis');
            if (!washSaleSection) {
                washSaleSection = document.createElement('div');
                washSaleSection.id = 'wash-sale-analysis';
                washSaleSection.className = 'mt-6 p-4 border-l-4 border-red-400 bg-red-50';
                
                // Insert after recommendations table
                const recommendationsContainer = document.getElementById('recommendations');
                recommendationsContainer.appendChild(washSaleSection);
            }

            const formatCurrency = (num) => num.toLocaleString('en-US', { style: 'currency', currency: 'USD' });

            let washSaleHTML = `
                <div class="flex">
                    <div class="flex-shrink-0">
                        <svg class="h-5 w-5 text-red-400" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor">
                            <path fill-rule="evenodd" d="M8.257 3.099c.765-1.36 2.722-1.36 3.486 0l5.58 9.92c.75 1.334-.21 3.03-1.742 3.03H4.42c-1.532 0-2.492-1.696-1.742-3.03l5.58-9.92zM10 13a1 1 0 110-2 1 1 0 010 2zm-1-4a1 1 0 011-1h.01a1 1 0 110 2H10a1 1 0 01-1-1z" clip-rule="evenodd" />
                        </svg>
                    </div>
                    <div class="ml-3">
                        <h3 class="text-sm font-medium text-red-800">Wash Sale Risk Detected</h3>
                        <div class="mt-2 text-sm text-red-700">
                            <p class="mb-3">
                                <strong>Warning:</strong> The following recommended trades may trigger wash sale violations under IRS Section 1091. 
                                This could result in the disallowance of ${formatCurrency(violations.reduce((sum, v) => sum + v.disallowedLoss, 0))} in tax losses.
                            </p>
            `;

            // Display each violation
            violations.forEach((violation, index) => {
                const riskColor = violation.riskTier.tier === 1 ? 'red' : 'yellow';
                const bgColor = violation.riskTier.tier === 1 ? 'bg-red-100' : 'bg-yellow-100';
                const textColor = violation.riskTier.tier === 1 ? 'text-red-800' : 'text-yellow-800';
                
                washSaleHTML += `
                    <div class="mt-4 p-3 ${bgColor} rounded-lg border border-${riskColor}-200">
                        <div class="flex items-start">
                            <div class="flex-shrink-0">
                                <span class="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-${riskColor}-100 text-${riskColor}-800">
                                    ${violation.riskTier.level}
                                </span>
                            </div>
                            <div class="ml-3 flex-1">
                                <h4 class="text-sm font-medium ${textColor}">
                                    Violation ${index + 1}: ${violation.soldSymbol} → ${violation.purchasedSymbol}
                                </h4>
                                <p class="mt-1 text-sm ${textColor}">
                                    ${violation.description}
                                </p>
                                <div class="mt-2 text-xs ${textColor}">
                                    <p><strong>Similarity Score:</strong> ${violation.similarityScore}/100</p>
                                    <p><strong>Potential Disallowed Loss:</strong> ${formatCurrency(violation.disallowedLoss)}</p>
                                </div>
                            </div>
                        </div>
                    </div>
                `;
            });

            // Display alternatives if available
            if (alternatives.length > 0) {
                washSaleHTML += `
                    <div class="mt-4">
                        <h4 class="text-sm font-medium text-red-800 mb-3">Recommended Alternatives:</h4>
                `;

                alternatives.forEach(alt => {
                    washSaleHTML += `
                        <div class="mb-4 p-3 bg-green-50 rounded-lg border border-green-200">
                            <h5 class="text-sm font-medium text-green-800">
                                Instead of ${alt.violatedSymbol}, consider:
                            </h5>
                            <div class="mt-2 grid grid-cols-1 gap-2">
                    `;

                    alt.alternatives.slice(0, 3).forEach(alternative => {
                        washSaleHTML += `
                            <div class="flex items-center justify-between p-2 bg-white rounded border border-green-200">
                                <div>
                                    <span class="font-medium text-gray-900">${alternative.symbol}</span>
                                    <span class="text-sm text-gray-600 ml-2">${alternative.name}</span>
                                </div>
                                <div class="text-right">
                                    <div class="text-xs text-gray-500">${alternative.index}</div>
                                    <div class="text-xs text-green-600">Risk Score: ${alternative.similarityScore}</div>
                                </div>
                            </div>
                        `;
                    });

                    washSaleHTML += `
                            </div>
                        </div>
                    `;
                });

                washSaleHTML += `</div>`;
            }

            washSaleHTML += `
                            <div class="mt-4 p-3 bg-blue-50 rounded-lg border border-blue-200">
                                <p class="text-sm text-blue-800">
                                    <strong>Important:</strong> This analysis is for informational purposes only. 
                                    Consult with your tax advisor before executing any trades that may trigger wash sale rules.
                                    The 61-day wash sale period includes 30 days before and after the sale date.
                                </p>
                            </div>
                        </div>
                    </div>
                </div>
            `;

            washSaleSection.innerHTML = washSaleHTML;
        }

        function displayResults(recommendations, targets, excludedPositions = []) {
            recommendationsTable.innerHTML = '';
            noTradesMsg.classList.toggle('hidden', recommendations.length > 0);

            const groupedBySymbol = recommendations.reduce((acc, lot) => {
                acc[lot.symbol] = acc[lot.symbol] || [];
                acc[lot.symbol].push(lot);
                return acc;
            }, {});

            let totalGainFromTrades = 0, stGainFromTrades = 0, ltGainFromTrades = 0, totalMarketValueFromTrades = 0;
            let hasLosses = false;

            const formatCurrency = (num) => num.toLocaleString('en-US', { style: 'currency', currency: 'USD' });

            for (const symbol in groupedBySymbol) {
                const lots = groupedBySymbol[symbol];
                const totalSymbolQty = lots.reduce((sum, l) => sum + l.quantity, 0);
                const totalSymbolGain = lots.reduce((sum, l) => sum + l.unrealizedGain, 0);
                const totalSymbolMarketValue = lots.reduce((sum, l) => sum + l.marketValue, 0);

                totalMarketValueFromTrades += totalSymbolMarketValue;

                const parentRow = document.createElement('tr');
                parentRow.className = 'parent-row font-medium text-gray-800';
                parentRow.dataset.symbol = symbol;
                parentRow.innerHTML = `
                    <td class="px-6 py-3 whitespace-nowrap"><span class="inline-flex items-center"><svg class="h-5 w-5 mr-2 text-gray-400 transition-transform duration-200" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M7.293 14.707a1 1 0 010-1.414L10.586 10 7.293 6.707a1 1 0 011.414-1.414l4 4a1 1 0 010 1.414l-4 4a1 1 0 01-1.414 0z" clip-rule="evenodd" /></svg><span class="px-2 inline-flex text-xs leading-5 font-semibold rounded-full ${totalSymbolGain < 0 ? 'bg-red-100 text-red-800' : 'bg-green-100 text-green-800'}">SELL GROUP</span></span></td>
                    <td class="px-6 py-3 whitespace-nowrap">${symbol}</td>
                    <td class="px-6 py-3 whitespace-nowrap">${totalSymbolQty.toLocaleString()}</td>
                    <td class="px-6 py-3 whitespace-nowrap text-sm text-gray-500">Multiple Lots</td>
                    <td class="px-6 py-3 whitespace-nowrap text-sm text-right text-gray-600">${formatCurrency(totalSymbolMarketValue)}</td>
                    <td class="px-6 py-3 whitespace-nowrap text-sm text-right ${totalSymbolGain < 0 ? 'text-red-600' : 'text-green-600'} font-semibold">${formatCurrency(totalSymbolGain)}</td>
                `;
                recommendationsTable.appendChild(parentRow);

                lots.forEach(lot => {
                    const gain = lot.unrealizedGain;
                    if (gain < 0) hasLosses = true;
                    totalGainFromTrades += gain;
                    if (lot.term === 'Short') stGainFromTrades += gain; else ltGainFromTrades += gain;

                    const childRow = document.createElement('tr');
                    childRow.className = 'child-row hidden';
                    childRow.dataset.parentSymbol = symbol;
                    childRow.innerHTML = `
                        <td class="px-6 py-4 whitespace-nowrap"></td>
                        <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">${lot.symbol}</td>
                        <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">${lot.quantity.toLocaleString()}</td>
                        <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">${lot.acquired}</td>
                        <td class="px-6 py-4 whitespace-nowrap text-sm text-right text-gray-500">${formatCurrency(lot.marketValue)}</td>
                        <td class="px-6 py-4 whitespace-nowrap text-sm text-right ${gain < 0 ? 'text-red-600' : 'text-green-600'}">${formatCurrency(gain)}</td>
                    `;
                    recommendationsTable.appendChild(childRow);
                });
            }

            washSaleWarning.classList.toggle('hidden', !hasLosses);

            const finalST = targets.realizedST + stGainFromTrades;
            const finalLT = targets.realizedLT + ltGainFromTrades;
            const formatCurrencyWithSign = (num) => num.toLocaleString('en-US', { style: 'currency', currency: 'USD', signDisplay: 'auto' });

            lastSummaryData = {
                finalST, finalLT, totalGainFromTrades, totalMarketValueFromTrades,
                targetST: targets.targetST,
                targetLT: targets.targetLT,
            };

            let summaryHTML;
            
            if (targets.mode === 'cashRaising') {
                // Cash Raising Mode Summary
                const cashShortfall = Math.max(0, targets.cashAmount - targets.cashRaised);
                const cashExcess = Math.max(0, targets.cashRaised - targets.cashAmount);
                
                summaryHTML = `
                    <div class="text-center">
                        <p class="text-sm text-gray-500">Cash Target</p>
                        <p class="text-lg font-medium text-blue-600">${formatCurrency(targets.cashAmount)}</p>
                        <p class="text-sm text-gray-500">Cash Generated</p>
                        <p class="text-xl font-bold ${targets.cashRaised >= targets.cashAmount ? 'text-green-700' : 'text-orange-600'}">${formatCurrency(targets.cashRaised)}</p>
                        <p class="text-xs text-gray-500">${cashExcess > 0 ? `(+${formatCurrency(cashExcess)} excess)` : cashShortfall > 0 ? `(-${formatCurrency(cashShortfall)} shortfall)` : '(Target met)'}</p>
                    </div>
                    <div class="text-center">
                        <p class="text-sm text-gray-500">Short-Term Impact</p>
                        <p class="text-lg font-medium">
                            <span class="${targets.stGain > 0 ? 'text-orange-600' : 'text-gray-500'}">${formatCurrencyWithSign(targets.stGain || 0)} gain</span>
                            <span class="text-gray-400 mx-1">+</span>
                            <span class="${targets.stLoss < 0 ? 'text-green-600' : 'text-gray-500'}">${formatCurrencyWithSign(targets.stLoss || 0)} loss</span>
                        </p>
                        <p class="text-xs text-gray-500">
                            ${targets.constraints && targets.constraints.maxSTGain < Infinity ? `Max gain: ${formatCurrency(targets.constraints.maxSTGain)}` : 'No gain limit'}
                            ${targets.constraints && targets.constraints.minSTLoss > -Infinity ? ` | Min loss: ${formatCurrencyWithSign(targets.constraints.minSTLoss)}` : ''}
                        </p>
                    </div>
                    <div class="text-center">
                        <p class="text-sm text-gray-500">Long-Term Impact</p>
                        <p class="text-lg font-medium">
                            <span class="${targets.ltGain > 0 ? 'text-orange-600' : 'text-gray-500'}">${formatCurrencyWithSign(targets.ltGain || 0)} gain</span>
                            <span class="text-gray-400 mx-1">+</span>
                            <span class="${targets.ltLoss < 0 ? 'text-green-600' : 'text-gray-500'}">${formatCurrencyWithSign(targets.ltLoss || 0)} loss</span>
                        </p>
                        <p class="text-xs text-gray-500">
                            ${targets.constraints && targets.constraints.maxLTGain < Infinity ? `Max gain: ${formatCurrency(targets.constraints.maxLTGain)}` : 'No gain limit'}
                            ${targets.constraints && targets.constraints.minLTLoss > -Infinity ? ` | Min loss: ${formatCurrencyWithSign(targets.constraints.minLTLoss)}` : ''}
                        </p>
                    </div>
                    <div class="text-center">
                        <p class="text-sm text-gray-500">Optimization Result</p>
                        <p class="text-xl font-bold ${targets.thresholdsMet ? 'text-green-700' : 'text-orange-600'}">
                            ${targets.thresholdsMet ? 'Constraints Met' : 'Constraints Relaxed'}
                        </p>
                        <p class="text-xs text-gray-500">
                            Strategy: ${targets.strategy === 'minimize_tax' ? 'Minimize Tax' : targets.strategy === 'maximize_cash' ? 'Maximize Cash' : 'Balanced'}
                        </p>
                    </div>
                `;
            } else {
                // Tax Target Mode Summary (original)
                summaryHTML = `
                    <div class="text-center">
                        <p class="text-sm text-gray-500">Current ST Gain/Loss</p>
                        <p class="text-lg font-medium ${targets.realizedST < 0 ? 'text-red-600' : 'text-green-700'}">${formatCurrencyWithSign(targets.realizedST)}</p>
                        <p class="text-sm text-gray-500">Projected Final ST Gain/Loss</p>
                        <p class="text-xl font-bold ${finalST < 0 ? 'text-red-600' : 'text-green-700'}">${formatCurrencyWithSign(finalST)}</p>
                        <p class="text-xs text-gray-500">(Target: ${formatCurrencyWithSign(targets.targetST)})</p>
                    </div>
                    <div class="text-center">
                        <p class="text-sm text-gray-500">Current LT Gain/Loss</p>
                        <p class="text-lg font-medium ${targets.realizedLT < 0 ? 'text-red-600' : 'text-green-700'}">${formatCurrencyWithSign(targets.realizedLT)}</p>
                        <p class="text-sm text-gray-500">Projected Final LT Gain/Loss</p>
                        <p class="text-xl font-bold ${finalLT < 0 ? 'text-red-600' : 'text-green-700'}">${formatCurrencyWithSign(finalLT)}</p>
                        <p class="text-xs text-gray-500">(Target: ${formatCurrencyWithSign(targets.targetLT)})</p>
                    </div>
                    <div class="text-center">
                        <p class="text-sm text-gray-500">Total Gain/Loss from Trades</p>
                        <p class="text-xl font-bold ${totalGainFromTrades < 0 ? 'text-red-600' : 'text-green-700'}">${formatCurrencyWithSign(totalGainFromTrades)}</p>
                        <p class="text-xs text-gray-500">(${recommendations.length} lots)</p>
                    </div>
                    <div class="text-center">
                        <p class="text-sm text-gray-500">Total Market Value of Trades</p>
                        <p class="text-xl font-bold text-gray-800">${formatCurrency(totalMarketValueFromTrades)}</p>
                        <p class="text-xs text-gray-400">&nbsp;</p> <!-- Placeholder for alignment -->
                    </div>
                `;
            }

            // Add excluded positions summary if any
            if (excludedPositions.length > 0) {
                const excludedValue = excludedPositions.reduce((sum, pos) => sum + pos.marketValue, 0);
                const excludedSymbols = [...new Set(excludedPositions.map(pos => pos.symbol))];

                summaryHTML += `
                    <div class="col-span-full mt-4 p-3 bg-yellow-50 rounded-lg border border-yellow-200">
                        <h4 class="text-sm font-medium text-yellow-800 mb-2">Excluded from Selling Algorithm:</h4>
                        <div class="text-xs text-yellow-700">
                            <p><span class="font-medium">${excludedPositions.length} lots</span> from <span class="font-medium">${excludedSymbols.length} symbols</span> (${excludedSymbols.join(', ')})</p>
                            <p>Total excluded market value: <span class="font-medium">${formatCurrency(excludedValue)}</span></p>
                        </div>
                    </div>
                `;
            }

            summaryDiv.innerHTML = summaryHTML;
        }

        function handleRowToggle(event) {
            const parentRow = event.target.closest('.parent-row');
            if (!parentRow) return;
            const symbol = parentRow.dataset.symbol;
            const childRows = recommendationsTable.querySelectorAll(`tr[data-parent-symbol="${symbol}"]`);
            parentRow.querySelector('svg').classList.toggle('icon-rotate');
            childRows.forEach(row => row.classList.toggle('hidden'));
        }

        function handleWashSaleCheck() {
            if (lastRecommendations.length === 0) {
                alert("Please generate recommendations first before checking for wash sale violations.");
                return;
            }
            
            // Perform wash sale analysis on current recommendations
            const violations = checkWashSaleViolations(lastRecommendations);
            
            if (violations.length === 0) {
                alert("✅ No wash sale violations detected! Your recommended trades appear to comply with IRS Section 1091.");
                return;
            }
            
            // Generate alternatives for violated positions
            const alternatives = [];
            violations.forEach(violation => {
                const soldETF = etfDatabase[violation.soldSymbol];
                const purchasedETF = etfDatabase[violation.purchasedSymbol];
                
                if (soldETF && purchasedETF) {
                    const alternativeETFs = findWashSaleAlternatives(
                        violation.purchasedSymbol, 
                        purchasedETF.assetClass, 
                        purchasedETF.style
                    );
                    
                    alternatives.push({
                        violatedSymbol: violation.purchasedSymbol,
                        soldSymbol: violation.soldSymbol,
                        riskTier: violation.riskTier,
                        alternatives: alternativeETFs
                    });
                }
            });
            
            // Display wash sale warnings
            displayWashSaleWarnings(violations, alternatives);
            
            // Scroll to wash sale section
            const washSaleSection = document.getElementById('wash-sale-analysis');
            if (washSaleSection) {
                washSaleSection.scrollIntoView({ behavior: 'smooth', block: 'start' });
            }
        }

        function handleDemoWashSale() {
            // Create demo data with wash sale violations
            const demoRecommendations = [
                {
                    symbol: 'IVV',
                    quantity: 100,
                    marketValue: 45000,
                    costBasis: 47000,
                    unrealizedGain: -2000,
                    term: 'Long',
                    acquired: '2023-01-15'
                },
                {
                    symbol: 'VTI',
                    quantity: 50,
                    marketValue: 11000,
                    costBasis: 12000,
                    unrealizedGain: -1000,
                    term: 'Short',
                    acquired: '2023-08-10'
                }
            ];
            
            // Set up demo portfolio data that will trigger violations
            portfolioData = [
                ...demoRecommendations,
                {
                    symbol: 'VOO', // This will conflict with IVV sale
                    quantity: 25,
                    marketValue: 11000,
                    costBasis: 10500,
                    unrealizedGain: 500,
                    term: 'Long',
                    acquired: '2023-12-01' // Recent purchase
                },
                {
                    symbol: 'ITOT', // This will conflict with VTI sale
                    quantity: 30,
                    marketValue: 6500,
                    costBasis: 6200,
                    unrealizedGain: 300,
                    term: 'Short',
                    acquired: '2023-11-15' // Recent purchase
                }
            ];
            
            // Set lastRecommendations for wash sale analysis
            lastRecommendations = demoRecommendations;
            
            // Show results container
            resultsContainer.classList.remove('hidden');
            
            // Use enhanced recommendation system with wash sale detection
            const analysisResult = generateAdvancedRecommendationsWithWashSaleCheck(0, -3000);
            
            // Set demo summary data
            lastSummaryData = {
                finalST: 0,
                finalLT: -3000,
                totalGainFromTrades: -3000,
                totalMarketValueFromTrades: 56000,
                targetST: 0,
                targetLT: -3000
            };
            
            // Display results with wash sale warnings
            displayResultsWithWashSaleAnalysis(analysisResult, { realizedST: 0, realizedLT: 0, targetST: 0, targetLT: -3000 }, []);
            
            // Show all buttons
            recommendationsDiv.classList.remove('hidden');
            exportBtn.classList.remove('hidden');
            proceedToBuyBtn.classList.remove('hidden');
            washSaleCheckBtn.classList.remove('hidden');
            aiRationaleSection.classList.remove('hidden');
            
            alert("Demo loaded! This shows wash sale violations between IVV→VOO and VTI→ITOT. Check the wash sale warnings below.");
        }

        function handleExport() {
            if (lastRecommendations.length === 0) {
                alert("No recommendations to export.");
                return;
            }

            // Save data for report
            saveReportData();

            const accountNumber = document.getElementById('accountNumber').value || 'N/A';
            const headers = [
                "Account Number", "Security Symbol", "Purchase Date", "Quantity Owned",
                "Original Purchase Price", "Cost Per Share", "Cost Basis",
                "Period (LT or ST)", "Share Quantity to Sell", "Action", "Price"
            ];

            const rows = lastRecommendations.map(lot => {
                const row = [
                    accountNumber,
                    `"${lot.symbol}"`,
                    lot.acquired,
                    lot.quantity,
                    lot.costPerShare.toFixed(2),
                    lot.costPerShare.toFixed(2),
                    lot.costBasis.toFixed(2),
                    lot.term,
                    lot.quantity, // Share Quantity to Sell is the full lot
                    "Sell",
                    lot.price.toFixed(2)
                ];
                return row.join(',');
            });

            const csvContent = [headers.join(','), ...rows].join('\n');
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement("a");
            const url = URL.createObjectURL(blob);
            link.setAttribute("href", url);
            link.setAttribute("download", `trades_for_acct_${accountNumber}.csv`);
            link.style.visibility = 'hidden';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        function handleProceedToBuy() {
            if (lastRecommendations.length === 0) {
                alert("No recommendations available to proceed with buy orders.");
                return;
            }

            // Save data for report
            saveReportData();

            // Calculate total market value from trades (cash generated from sales)
            const totalCashFromSales = lastSummaryData.totalMarketValueFromTrades;

            // Get client info to transfer
            const clientName = document.getElementById('clientName').value;
            const custodian = document.getElementById('custodian').value;
            const accountNumber = document.getElementById('accountNumber').value;

            // Store data in localStorage to transfer to buy-orders page
            const transferData = {
                cashFromSales: totalCashFromSales,
                clientName: clientName,
                custodian: custodian,
                accountNumber: accountNumber,
                timestamp: new Date().toISOString()
            };

            localStorage.setItem('taxHarvestingTransfer', JSON.stringify(transferData));

            // Store sell orders for wash sale detection
            const sellOrders = lastRecommendations.map(rec => ({
                symbol: rec.symbol,
                shares: rec.sharesToSell,
                price: rec.currentPrice || rec.price,
                marketValue: rec.marketValue,
                actualGain: rec.actualGain,
                name: rec.name,
                account: rec.account,
                lotId: rec.lotId
            }));

            localStorage.setItem('sellOrders', JSON.stringify(sellOrders));
            console.log('Stored sell orders for wash sale detection:', sellOrders);

            // Navigate to buy-orders page
            window.location.href = 'buy-orders.html';
        }

        function saveReportData() {
            const clientName = document.getElementById('clientName').value;
            const custodian = document.getElementById('custodian').value;
            const accountNumber = document.getElementById('accountNumber').value;
            const realizedST = parseFloat(document.getElementById('realizedST').value) || 0;
            const realizedLT = parseFloat(document.getElementById('realizedLT').value) || 0;
            
            let reportData = {
                client: {
                    name: clientName,
                    custodian: custodian,
                    accountNumber: accountNumber
                },
                mode: currentMode,
                realizedST: realizedST,
                realizedLT: realizedLT,
                finalST: lastSummaryData.finalST || 0,
                finalLT: lastSummaryData.finalLT || 0,
                totalGainLoss: lastSummaryData.totalGainFromTrades || 0,
                totalMarketValue: lastSummaryData.totalMarketValueFromTrades || 0,
                recommendations: lastRecommendations,
                totalPositions: portfolioData.length,
                selectedPositions: portfolioData.filter(lot => lot.includedInSelling).length,
                excludedPositions: portfolioData.filter(lot => !lot.includedInSelling).length,
                timestamp: new Date().toISOString()
            };
            
            if (currentMode === 'taxTarget') {
                const targetST = parseFloat(document.getElementById('targetST').value) || 0;
                const targetLT = parseFloat(document.getElementById('targetLT').value) || 0;
                reportData.targetST = targetST;
                reportData.targetLT = targetLT;
            } else {
                const cashAmount = parseFloat(document.getElementById('cashAmount').value) || 0;
                reportData.cashAmount = cashAmount;
                reportData.cashRaised = lastSummaryData.totalMarketValueFromTrades || 0;
                reportData.cashExcess = (lastSummaryData.totalMarketValueFromTrades || 0) - cashAmount;
            }

            localStorage.setItem('taxHarvestingReport', JSON.stringify(reportData));
        }

        // AI Rationale Functions
        function handleGenerateAiRationale() {
            if (lastRecommendations.length === 0) {
                alert("Please generate recommendations first before requesting AI analysis.");
                return;
            }

            aiRationaleSection.classList.remove('hidden');
            aiRationaleLoading.classList.remove('hidden');
            aiRationaleContent.classList.add('hidden');
            generateAiRationaleBtn.disabled = true;

            // Simulate AI analysis (replace with actual AI API call)
            setTimeout(() => {
                const analysisText = generateMockAiAnalysis();
                aiRationaleText.textContent = analysisText;
                
                aiRationaleLoading.classList.add('hidden');
                aiRationaleContent.classList.remove('hidden');
                generateAiRationaleBtn.disabled = false;
            }, 2000);
        }

        function generateMockAiAnalysis() {
            const totalTrades = lastRecommendations.length;
            const totalGain = lastSummaryData.totalGainFromTrades || 0;
            const stGain = lastSummaryData.finalST - (lastSummaryData.targetST - lastSummaryData.finalST + totalGain);
            const ltGain = lastSummaryData.finalLT - (lastSummaryData.targetLT - lastSummaryData.finalLT + totalGain);
            
            // Check for wash sale violations in current recommendations
            const washSaleAnalysis = checkWashSaleViolations(lastRecommendations);
            
            let analysis = `Based on your portfolio analysis and tax optimization goals, here's my comprehensive assessment:\n\n`;
            
            analysis += `STRATEGY OVERVIEW:\n`;
            analysis += `The algorithm has identified ${totalTrades} optimal positions for sale, generating an estimated ${totalGain >= 0 ? 'gain' : 'loss'} of $${Math.abs(totalGain).toLocaleString()}.\n\n`;
            
            // Wash Sale Risk Assessment
            if (washSaleAnalysis.length > 0) {
                analysis += `⚠️  WASH SALE RISK ANALYSIS:\n`;
                analysis += `WARNING: ${washSaleAnalysis.length} potential wash sale violation(s) detected!\n`;
                washSaleAnalysis.forEach((violation, index) => {
                    analysis += `${index + 1}. ${violation.riskTier.level}: Selling ${violation.soldSymbol} while holding/buying ${violation.purchasedSymbol}\n`;
                    analysis += `   Similarity Score: ${violation.similarityScore}/100 - ${violation.riskTier.description}\n`;
                    analysis += `   Potential disallowed loss: $${violation.disallowedLoss.toLocaleString()}\n`;
                });
                analysis += `\nRecommendation: Review alternative ETFs provided to avoid triggering IRS Section 1091.\n\n`;
            } else {
                analysis += `✅ WASH SALE COMPLIANCE:\n`;
                analysis += `No wash sale violations detected. Your proposed trades comply with IRS Section 1091 requirements.\n\n`;
            }
            
            if (totalGain < 0) {
                analysis += `TAX BENEFITS:\n`;
                analysis += `• The realized losses can offset other capital gains in your portfolio\n`;
                analysis += `• Up to $3,000 of excess losses can offset ordinary income annually\n`;
                analysis += `• Unused losses carry forward indefinitely to future tax years\n`;
                if (washSaleAnalysis.length > 0) {
                    analysis += `• However, wash sale violations could defer these tax benefits\n`;
                }
                analysis += `\n`;
            }
            
            analysis += `PORTFOLIO IMPACT:\n`;
            analysis += `• Short-term position impact: $${Math.abs(stGain).toLocaleString()}\n`;
            analysis += `• Long-term position impact: $${Math.abs(ltGain).toLocaleString()}\n`;
            analysis += `• Total market value being sold: $${lastSummaryData.totalMarketValueFromTrades?.toLocaleString() || '0'}\n\n`;
            
            analysis += `COMPLIANCE RECOMMENDATIONS:\n`;
            if (washSaleAnalysis.length > 0) {
                analysis += `• PRIORITY: Address wash sale violations before executing trades\n`;
                analysis += `• Consider recommended alternative ETFs that maintain similar exposure\n`;
                analysis += `• Review all accounts (including spouse's) for recent purchases\n`;
            }
            analysis += `• Verify no substantially identical securities purchased 30 days before sale date\n`;
            analysis += `• Plan replacement investments outside the 61-day wash sale window\n`;
            analysis += `• Document all transactions for accurate tax reporting\n\n`;
            
            analysis += `NEXT STEPS:\n`;
            analysis += `1. ${washSaleAnalysis.length > 0 ? '⚠️  RESOLVE WASH SALE ISSUES FIRST' : '✅ Review and approve the recommended trades'}\n`;
            analysis += `2. ${washSaleAnalysis.length > 0 ? 'Select alternative ETFs from provided recommendations' : 'Export the trade list for your broker'}\n`;
            analysis += `3. Coordinate execution timing with your tax advisor\n`;
            analysis += `4. Monitor the 61-day period to avoid future wash sale violations\n\n`;
            
            analysis += `LEGAL DISCLAIMER:\n`;
            analysis += `This analysis is for informational purposes only and does not constitute tax or legal advice. `;
            analysis += `Wash sale determinations depend on specific facts and circumstances. `;
            analysis += `Consult your tax advisor before executing any trades.`;
            
            return analysis;
        }

        function handleCopyRationale() {
            const text = aiRationaleText.textContent;
            if (!text) {
                alert("No analysis to copy.");
                return;
            }

            navigator.clipboard.writeText(text).then(() => {
                const originalText = copyRationaleBtn.innerHTML;
                copyRationaleBtn.innerHTML = `
                    <svg class="w-4 h-4 mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"></path>
                    </svg>
                    Copied!
                `;
                
                setTimeout(() => {
                    copyRationaleBtn.innerHTML = originalText;
                }, 2000);
            }).catch(() => {
                alert("Failed to copy to clipboard. Please select and copy manually.");
            });
        }

        // Mobile menu functionality
        document.addEventListener('DOMContentLoaded', function() {
            try {
                const mobileMenuButton = document.getElementById('mobile-menu-button');
                const mobileMenu = document.getElementById('mobile-menu');
                
                if (mobileMenuButton && mobileMenu) {
                    mobileMenuButton.addEventListener('click', function(e) {
                        e.preventDefault();
                        mobileMenu.classList.toggle('hidden');
                        console.log('Mobile menu toggled');
                    });
                    console.log('Mobile menu initialized successfully');
                } else {
                    console.error('Mobile menu elements not found:', {
                        button: !!mobileMenuButton,
                        menu: !!mobileMenu
                    });
                }
                
                // Add click handlers for navigation links to ensure they work
                const navLinks = document.querySelectorAll('.nav-link, .mobile-nav-link');
                navLinks.forEach(link => {
                    link.addEventListener('click', function(e) {
                        const href = this.getAttribute('href');
                        if (href && href !== '#') {
                            console.log('Navigating to:', href);
                            // Let the browser handle the navigation normally
                        }
                    });
                });
                
            } catch (error) {
                console.error('Navigation initialization error:', error);
            }
        });
    </script>
</div> <!-- End content-area -->
</body>

</html>